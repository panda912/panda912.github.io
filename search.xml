<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[反编译 jar 包修改代码后重新打包]]></title>
      <url>%2F2017%2F05%2F10%2F%E5%8F%8D%E7%BC%96%E8%AF%91-jar-%E5%8C%85%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E5%90%8E%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85%2F</url>
      <content type="text"><![CDATA[定位要修改的类，新建一个工程，包名与 jar 包名一致，新建同名的类，将 class 中的代码拷贝进去，然后将 jar 包中要修改的类删除，将删除后的类的 jar 包添加到新的工程中，重新编译，将编译后的 class 文件拷贝到 jar 包中，over！ 举个栗子： 现在如果要修改 udesk jar 包中的 e、f、g、h、l、UdeskHttpFacade.class 文件，新建一个工程，包名一致，新建需要修改的同名的类文件，将代码拷贝进去 删除原 jar 包中需要修改的 class 文件，将新的 jar 包放进新的工程 libs 下 修改需要修改的代码，使其能够正确编译，编译之后拷贝生成对应的 class 文件，放进新的 jar 包中 PS: mac 下没有找到可以直接删除 jar 中的 class 文件的工具，在 windows 下可以直接用 winrar 打开，直接删除或者添加 class 文件。 PS: 如果反编译修改类似 Activity 这样涉及到资源文件的 class 文件，需要在原工程中新建包名去修改，如果在新的工程中修改，生成的资源 id 与在原工程中不一致，导致发生错误。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android各大直播SDK分析]]></title>
      <url>%2F2017%2F04%2F26%2FAndroid%E5%90%84%E5%A4%A7%E7%9B%B4%E6%92%ADSDK%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[1. 百度云音视频直播 LSS:2. 七牛直播云：Pili 直播 SDK https://github.com/pili-engineering/PLDroidMediaStreaming https://github.com/pili-engineering/PLDroidPlayer 3. 腾讯云直播：4. 阿里云视频直播：5. 趣拍云：6. 金山云：https://github.com/ksvc/KSYLive_Android https://github.com/ksvc/KSYMediaPlayer_Android 音视频采集、推流、播放免费，云存储、CDN 分发、动态贴纸、连麦、第三方美颜等收费。 7. 即构：客户案例：花椒直播、映客直播等 8. EasyDarwin：https://github.com/EasyDarwin/EasyDarwin 开源+商业 9. 大牛直播：https://github.com/daniulive/SmarterStreaming SmarterStreaming SDK可供个人学习之用，企业及商用需要经过授权 10. 来疯直播开源项目：https://github.com/LaiFeng-Android/SopCastComponent 11. yasea：https://github.com/begeekmyfriend/yasea RTMP live streaming client for Android 软硬解码，本地记录，滤镜 12. EvilsLive:https://github.com/ThinkKeep/EvilsLive 视频采集、推流、预览、播放、美图 Android Studio &gt;= 2.2.3Android API &gt;= 19 [x] 视频编码：H.264 [x] 推流协议：RTMP [x] 预览与推流分辨率可分别自由设置 [x] 支持前、后置摄像头动态切换 [ ] 支持软编、硬编及软编兼容模式 [ ] 网络自适应，可根据实际网络情况动态调整目标码率，保证流畅性 [ ] 音频编码：AAC [ ] 支持动态横竖屏推流 [ ] 音视频目标码率：可设]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多层循环直接跳出最外层循环]]></title>
      <url>%2F2017%2F04%2F21%2F%E5%A4%9A%E5%B1%82%E5%BE%AA%E7%8E%AF%E7%9B%B4%E6%8E%A5%E8%B7%B3%E5%87%BA%E6%9C%80%E5%A4%96%E5%B1%82%E5%BE%AA%E7%8E%AF%2F</url>
      <content type="text"><![CDATA[BoringLayout.java 中的代码片段: 123456789101112131415161718192021222324252627282930313233outer:for (int start = 0; start &lt; textLength; start += MAX_BUF_LEN) &#123; final int end = Math.min(start + MAX_BUF_LEN, textLength); // No need to worry about getting half codepoints, since we reject surrogate code units // as non-boring as soon we see one. TextUtils.getChars(text, start, end, buffer, 0); final int len = end - start; for (int i = 0; i &lt; len; i++) &#123; final char c = buffer[i]; if (c == '\n' || c == '\t' || (c &gt;= 0x0590 &amp;&amp; c &lt;= 0x08FF) || // RTL scripts c == 0x200F || // Bidi format character (c &gt;= 0x202A &amp;&amp; c &lt;= 0x202E) || // Bidi format characters (c &gt;= 0x2066 &amp;&amp; c &lt;= 0x2069) || // Bidi format characters (c &gt;= 0xD800 &amp;&amp; c &lt;= 0xDFFF) || // surrogate pairs (c &gt;= 0xFB1D &amp;&amp; c &lt;= 0xFDFF) || // Hebrew and Arabic presentation forms (c &gt;= 0xFE70 &amp;&amp; c &lt;= 0xFEFE) // Arabic presentation forms ) &#123; boring = false; break outer; &#125; &#125; // TODO: This looks a little suspicious, and in some cases can result in O(n^2) // run time. Consider moving outside the loop. if (textDir != null &amp;&amp; textDir.isRtl(buffer, 0, len)) &#123; boring = false; break outer; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu 常用命令]]></title>
      <url>%2F2017%2F02%2F16%2Fubuntu-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[1dpkg -l | grep -i &quot;keyword&quot; 1sudo apt remove --purge XXX 1sudo apt autoremove 1wget &quot;http://xxxxx.zip&quot; 1uname -a 1uname -r 1top 1pidof xxx 1pkill xxx 1killall xxx 1sudo fdisk -l 1sudo umount /dev/sdb 1sudo dd if=xxx.iso of=/dev/sdb 1sudo dd if=xxx.iso of=/dev/sdb bs=2M]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android多线程之AsyncTask]]></title>
      <url>%2F2017%2F02%2F10%2FAndroid%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BAsyncTask%2F</url>
      <content type="text"><![CDATA[AsyncTask 的源码注释不要写的太详细哦。 AsyncTask enables proper and easy use of the UI thread. This class allows to perform background operations and publish results on the UI thread without having to manipulate threads and/or handlers. AsyncTask is designed to be a helper class around Thread and Handler and does not constitute a generic threading framework. AsyncTasks should ideally be used for short operations (a few seconds at the most.) If you need to keep threads running for long periods of time,it is highly recommended you use the various APIs provided by the java.util.concurrent package such as Executor, ThreadPoolExecutor and FutureTask. An asynchronous task is defined by a computation that runs on a background thread and whose result is published on the UI thread. An asynchronous task is defined by 3 generic types, called Params, Progress and Result, and 4 steps, called onPreExecute, doInBackground, onProgressUpdate and onPostExecute. Developer GuidesFor more information about using tasks and threads, read the Processes and Threads developer guide. UsageAsyncTask must be subclassed to be used. The subclass will override at least one method (doInBackground(Params...)), and most often will override a second one (onPostExecute(Result).) Here is an example of subclassing: 123456789101112131415161718192021private class DownloadFilesTask extends AsyncTask&lt;URL, Integer, Long&gt; &#123; protected Long doInBackground(URL... urls) &#123; int count = urls.length; long totalSize = 0; for (int i = 0; i &lt; count; i++) &#123; totalSize += Downloader.downloadFile(urls[i]); publishProgress((int) ((i / (float) count) * 100)); // Escape early if cancel() is called if (isCancelled()) break; &#125; return totalSize; &#125; protected void onProgressUpdate(Integer... progress) &#123; setProgressPercent(progress[0]); &#125; protected void onPostExecute(Long result) &#123; showDialog("Downloaded " + result + " bytes"); &#125;&#125; Once created, a task is executed very simply: 1new DownloadFilesTask().execute(url1, url2, url3); AsyncTask’s generic typesThe three types used by an asynchronous task are the following: Params, the type of the parameters sent to the task upon execution. Progress, the type of the progress units published during the background computation. Result, the type of the result of the background computation. Not all types are always used by an asynchronous task. To mark a type as unused, simply use the type Void: private class MyTask extends AsyncTask { … } The 4 stepsWhen an asynchronous task is executed, the task goes through 4 steps: onPreExecute(), invoked on the UI thread before the task is executed. This step is normally used to setup the task, for instance by showing a progress bar in the user interface. doInBackground(Params...), invoked on the background thread immediately after onPreExecute() finishes executing. This step is used to perform background computation that can take a long time. The parameters of the asynchronous task are passed to this step. The result of the computation must be returned by this step and will be passed back to the last step. This step can also use publishProgress(Progress...) to publish one or more units of progress. These values are published on the UI thread, in the onProgressUpdate(Progress...) step. onProgressUpdate(Progress...), invoked on the UI thread after a call to publishProgress(Progress...). The timing of the execution is undefined. This method is used to display any form of progress in the user interface while the background computation is still executing. For instance, it can be used to animate a progress bar or show logs in a text field. onPostExecute(Result), invoked on the UI thread after the background computation finishes. The result of the background computation is passed to this step as a parameter. Cancelling a taskA task can be cancelled at any time by invoking cancel(boolean). Invoking this method will cause subsequent calls to isCancelled() to return true. After invoking this method, onCancelled(Object), instead of onPostExecute(Object) will be invoked after doInBackground(Object[]) returns. To ensure that a task is cancelled as quickly as possible, you should always check the return value of isCancelled() periodically from doInBackground(Object[]), if possible (inside a loop for instance.) Threading rulesThere are a few threading rules that must be followed for this class to work properly: The AsyncTask class must be loaded on the UI thread. This is done automatically as of JELLY_BEAN. The task instance must be created on the UI thread. execute(Params...) must be invoked on the UI thread. Do not call onPreExecute(), onPostExecute(Result), doInBackground(Params...), onProgressUpdate(Progress...) manually. The task can be executed only once (an exception will be thrown if a second execution is attempted.) Memory observabilityAsyncTask guarantees that all callback calls are synchronized in such a way that the following operations are safe without explicit synchronizations. Set member fields in the constructor or onPreExecute(), and refer to them in doInBackground(Params...). Set member fields in doInBackground(Params...), and refer to them in onProgressUpdate(Progress...) and onPostExecute(Result). Order of executionWhen first introduced, AsyncTasks were executed serially on a single background thread. Starting with DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution. If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 之 Handler机制浅析]]></title>
      <url>%2F2017%2F02%2F06%2FAndroid-%E4%B9%8B-Handler%E6%9C%BA%E5%88%B6%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[关于 Handler 的用法相信大家都应该知道，比如这样： 123456789101112131415161718192021222324252627282930313233343536public class HandlerActivity extends AppCompatActivity &#123; private MyHandler mHandler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_handler); mHandler = new MyHandler(this); mHandler.sendMessage(mHandler.obtainMessage(0, "hello"));// Message message = Message.obtain();// message.what = 0;// message.obj = "hello world";// mHandler.sendMessage(message); &#125; private static class MyHandler extends Handler &#123; WeakReference&lt;Activity&gt; mActivity; MyHandler(Activity activity) &#123; mActivity = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case 0: Toast.makeText(mActivity.get(), (String) msg.obj, Toast.LENGTH_SHORT).show(); break; default: break; &#125; &#125; &#125;&#125; 我们从 Handler 的构造方法开始看起： 12345678910111213141516171819202122232425262728/** * Use the &#123;@link Looper&#125; for the current thread with the specified callback interface * and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make * one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering * with respect to synchronous messages. Asynchronous messages are not subject to * the synchronization barriers introduced by &#123;@link MessageQueue#enqueueSyncBarrier(long)&#125;. * * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls &#123;@link Message#setAsynchronous(boolean)&#125; for * each &#123;@link Message&#125; that is sent to it or &#123;@link Runnable&#125; that is posted to it. * * @hide */public Handler(Callback callback, boolean async) &#123; //...... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 先调用了 Looper.myLooper() 赋给 mLooper，点进去看看 myLooper() 方法的实现： 1234567/** * Return the Looper object associated with the current thread. Returns * null if the calling thread is not associated with a Looper. */public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 很简单，返回一个与当前线程相关联的 Looper 对象。如果调用线程没有与 Looper 关联则返回 null。那怎么关联呢？往下看。 获取到 Looper 之后调用 mLooper.mQueue 获取到当前线程关联的 Looper 中的消息队列 mQueue。 Looper 中的消息队列 mQueue 是在 Looper 的构造方法中创建的： 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 而 Looper 的构造方法是在哪儿调用的呢？看 prepare() 方法： 12345678910111213141516 /** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * &#123;@link #loop()&#125; after calling this method, and end it by calling * &#123;@link #quit()&#125;. */public static void prepare() &#123; prepare(true);&#125;private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 当 prepare() 方法被调用的时候，就会初始化一个 Looper 对象并与当前线程关联起来，而 Looper 中维护着一个消息队列 MessageQueue 。 当我们 new 一个 Handler 之后，调用 sendMessage(message) 方法或者是 sendXXX 等等诸如此类的方法发送消息， 最后都会走到 sendMessageAtTime 这个方法中，点进去看看它的实现： 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 如果 queue 不为 null ，调用 enqueueMessage 方法，再点进去看看实现： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 在这里把 this 赋给了 msg.target，这里的this 就是当前的 handler 对象，Message 中的 target 就是 Handler，在这里就把 Handler 和 Message 关联起来了，然后调用 MessageQueue 中的 enqueueMessage 方法，把当前的消息传到消息队列中去： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; 消息已经发出去了，那么在哪儿接收呢？ 调用 Looper.loop() 来循环消息队列： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 看36行，调用了 msg.target.dispatchMessage(msg) ，msg.target 就是 Handler ，就是调用了 Handler 的 dispatchMessage 方法来分发消息的： 123456789101112131415/** * Handle system messages here. */public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; msg.callback 是什么？是一个 Runnable ，如果指定了 Message 的 callback ，那就走 handleCallback(msg)： 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 否则，如果 mCallback != null ，则执行 mCallback.handleMessage(msg) ： 12345678910/** * Callback interface you can use when instantiating a Handler to avoid * having to implement your own subclass of Handler. * * @param msg A &#123;@link android.os.Message Message&#125; object * @return True if no further handling is desired */public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 如果 mCallback.handleMessage(msg) 返回 true，则执行完毕，否则，再执行最后的 handleMessage(msg) ： 12345/** * Subclasses must implement this to receive messages. */public void handleMessage(Message msg) &#123;&#125; 这个 handleMessage 就是我们创建 Handler 的时候重写的那个 handleMessage ，重写这个方法来处理接受到消息后的逻辑： 12345678910111213private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; //TODO &#125;&#125;;//或者private static class MyHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; //TODO &#125;&#125; 到此，整个流程就走完了，整理一下： Looper.prepare() ：调用 Looper.prepare() 的时候创建一个包含 MessageQueue 的 Looper 对象与当前线程关联； new Handler() ：在构造方法中通过 Looper.myLooper() 获取当前线程的 Looper 对象，然后获取了 Looper 中的 MessageQueue； 调用 sendXXX() : 会调用 enqueueMessage() ,把当前 Handler 实例赋给 Message 的 target ，最终调用 MessageQueue 的 enqueueMessage() ,把这个 Message 放进消息队列中； 调用 Looper.loop() 循环消息队列，msg.target.dispatchMessage(msg) 分发消息； 消息处理。 有人有疑问我们并没有调用 Looper.prepare() 和 Looper.loop() ，那是因为在 ActivityThread 的 main 方法中已经为我们写好了： 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; 在21行调用了 Looper.prepareMainLooper() ： 123456789public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException("The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125;&#125; 创建了唯一的 sMainLooper 实例，然后在37行调用了 Looper.loop() 。（PS：所以在主线程调用 Looper.myLooper() 和 Looper.getMainLooper()是一样的） 关于 Handler 的 post() ： 123456new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; //TODO &#125;&#125;, 2000); 123public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; 通过 getPostMessage 创建一个 Message ，并把 runnable 传给了 Message 的 callback ： 12345private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; 然后调用 sendMessageXXX -&gt; sendMessageAtTime -&gt; enqueueMessage -&gt; MessageQueue enqueueMessage …… 后面流程都一样了，然后在 dispatchMessage 的时候，因为 msg.callback != null ,所以就执行了 handleCallback(msg) ： 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 就是执行了 Runnable 的 run() 。 完毕。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android LayoutTransition 基本用法]]></title>
      <url>%2F2017%2F01%2F22%2FAndroid-LayoutTransition-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[简介LayoutTransition是在 API11 的时候引入的，用来设置当布局发生变化时的动画效果。有时候当我们addView、removeView 或者设置 View 的 GONE、VISIBLE 时，不想让布局的变化显得很突兀，想有一个过渡的效果，就在xml布局文件中设置android:animateLayoutChanges=&quot;true&quot;属性，这个属性就是用到了LayoutTransition。我们来看看官方提供的默认的动画是什么样子的： 先从ViewGroup的构造方法中看起: 12345public ViewGroup(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; super(context, attrs, defStyleAttr, defStyleRes); initViewGroup(); initFromAttributes(context, attrs, defStyleAttr, defStyleRes);&#125; 点进去initFromAttributes方法： 1234567891011121314151617181920212223private void initFromAttributes( Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123; final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewGroup, defStyleAttr, defStyleRes); final int N = a.getIndexCount(); for (int i = 0; i &lt; N; i++) &#123; int attr = a.getIndex(i); switch (attr) &#123; case ...... case ...... case R.styleable.ViewGroup_animateLayoutChanges: boolean animateLayoutChanges = a.getBoolean(attr, false); if (animateLayoutChanges) &#123; setLayoutTransition(new LayoutTransition()); &#125; break; case ...... case ...... &#125; &#125; a.recycle();&#125; 可以看到当我们设置android:animateLayoutChanges=&quot;true&quot;的时候，其实就是调用了setLayoutTransition(new LayoutTransition());设置默认的动画效果。我们今天主要来看看LayoutTransition这个类： 123456789101112131415161718192021222324252627282930313233343536public LayoutTransition() &#123; if (defaultChangeIn == null) &#123; // "left" is just a placeholder; we'll put real properties/values in when needed PropertyValuesHolder pvhLeft = PropertyValuesHolder.ofInt("left", 0, 1); PropertyValuesHolder pvhTop = PropertyValuesHolder.ofInt("top", 0, 1); PropertyValuesHolder pvhRight = PropertyValuesHolder.ofInt("right", 0, 1); PropertyValuesHolder pvhBottom = PropertyValuesHolder.ofInt("bottom", 0, 1); PropertyValuesHolder pvhScrollX = PropertyValuesHolder.ofInt("scrollX", 0, 1); PropertyValuesHolder pvhScrollY = PropertyValuesHolder.ofInt("scrollY", 0, 1); defaultChangeIn = ObjectAnimator.ofPropertyValuesHolder((Object)null, pvhLeft, pvhTop, pvhRight, pvhBottom, pvhScrollX, pvhScrollY); defaultChangeIn.setDuration(DEFAULT_DURATION); defaultChangeIn.setStartDelay(mChangingAppearingDelay); defaultChangeIn.setInterpolator(mChangingAppearingInterpolator); defaultChangeOut = defaultChangeIn.clone(); defaultChangeOut.setStartDelay(mChangingDisappearingDelay); defaultChangeOut.setInterpolator(mChangingDisappearingInterpolator); defaultChange = defaultChangeIn.clone(); defaultChange.setStartDelay(mChangingDelay); defaultChange.setInterpolator(mChangingInterpolator); defaultFadeIn = ObjectAnimator.ofFloat(null, "alpha", 0f, 1f); defaultFadeIn.setDuration(DEFAULT_DURATION); defaultFadeIn.setStartDelay(mAppearingDelay); defaultFadeIn.setInterpolator(mAppearingInterpolator); defaultFadeOut = ObjectAnimator.ofFloat(null, "alpha", 1f, 0f); defaultFadeOut.setDuration(DEFAULT_DURATION); defaultFadeOut.setStartDelay(mDisappearingDelay); defaultFadeOut.setInterpolator(mDisappearingInterpolator); &#125; mChangingAppearingAnim = defaultChangeIn; mChangingDisappearingAnim = defaultChangeOut; mChangingAnim = defaultChange; mAppearingAnim = defaultFadeIn; mDisappearingAnim = defaultFadeOut;&#125; 在LayoutTransition的构造方法中给我们实现好了默认的动画效果，总共包含4中动画效果，分别是： APPEARING：View出现动画，当View在父容器中出现时候的动画； DISAPPEARING：View消失动画，当View在父容器中消失时候的动画； CHANGE_APPEARING：由于某些View出现在父容器中时，容器中其他的View而发生变化时的动画； CHANGE_DISAPPEARING：由于某些View在父容器中消失时，容器中其他的View而发生变化时的动画。 我们可以调用setAnimator给LayoutTransition分别设置这些动画。 代码片段12345678910111213141516171819LayoutTransition layoutTransition = new LayoutTransition();mContentLL.setLayoutTransition(layoutTransition);//AppearingPropertyValuesHolder pvhAppearingTranslation = PropertyValuesHolder.ofFloat("translationX", 800, 0);PropertyValuesHolder pvhAppearingAlpha = PropertyValuesHolder.ofFloat("alpha", 0, 1);PropertyValuesHolder pvhAppearingScaleX = PropertyValuesHolder.ofFloat("scaleX", 0, 1);PropertyValuesHolder pvhAppearingScaleY = PropertyValuesHolder.ofFloat("scaleY", 0, 1);PropertyValuesHolder pvhAppearingRotationX = PropertyValuesHolder.ofFloat("rotationX", 0, 360);ObjectAnimator appearingAnimator = ObjectAnimator.ofPropertyValuesHolder((Object) null, pvhAppearingTranslation, pvhAppearingAlpha, pvhAppearingScaleX, pvhAppearingScaleY, pvhAppearingRotationX);//DisappearingPropertyValuesHolder pvhDisappearingTranslation = PropertyValuesHolder.ofFloat("translationX", 0, 800);PropertyValuesHolder pvhDisappearingAlpha = PropertyValuesHolder.ofFloat("alpha", 1, 0);PropertyValuesHolder pvhDisappearingScaleY = PropertyValuesHolder.ofFloat("scaleY", 1, 0);ObjectAnimator disappearingAnimator = ObjectAnimator.ofPropertyValuesHolder((Object) null, pvhDisappearingTranslation, pvhDisappearingAlpha, pvhDisappearingScaleY);layoutTransition.setAnimator(LayoutTransition.APPEARING, appearingAnimator);layoutTransition.setInterpolator(LayoutTransition.APPEARING, new OvershootInterpolator());layoutTransition.setDuration(LayoutTransition.APPEARING, 1200);layoutTransition.setAnimator(LayoutTransition.DISAPPEARING, disappearingAnimator);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Scroller 基本用法]]></title>
      <url>%2F2017%2F01%2F20%2FScroller-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Scroller是什么： Scroller是一个用来辅助View滚动的工具类。它本身并不能够控制 View 的滚动，它只是用来辅助滚动的。 小明：什么意思，我自己就可以让 View 滚动啊，为什么还要它来辅助我？ 老师问小明：在一个 ViewGroup 中把 A 点的一个 View 拉到 B 点，松手之后怎么让这个 View 再回到 A 点呢？奥，不对，是平滑的滚动到 A 点。 小明想了想：可以使用动画！ 老师：除了动画还有什么办法呢？ 小明：不知道了。 老师：（嘻嘻）可以用 Scroller。 这里为什么强调松手之后，这就可以解释 Scroller 是用来辅助 View 做滚动，而不是使用它来让 View 滚动。比方说我们触摸一个 View，松手之前，我们可以在onTouchEvent里用scrollTo或scrollBy来控制 View 的滚动，当松手之后就可以使用 Scroller 的 startScroll方法，设置 View 的X轴和Y轴方向上的偏移坐标（这个偏移坐标以 View 的左上方在父控件的坐标系中为准）以及对应方向上想要滚动的距离。 PS：scrollTo和scrollBy都可以滚动 View 中的内容！View 中的内容！View 中的内容！不是滚动 View 自身。但是两者又有区别，看源码： 1234567891011121314151617181920/** * Set the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the x position to scroll to * @param y the y position to scroll to */public void scrollTo(int x, int y) &#123; if (mScrollX != x || mScrollY != y) &#123; int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) &#123; postInvalidateOnAnimation(); &#125; &#125;&#125; 12345678910/** * Move the scrolled position of your view. This will cause a call to * &#123;@link #onScrollChanged(int, int, int, int)&#125; and the view will be * invalidated. * @param x the amount of pixels to scroll by horizontally * @param y the amount of pixels to scroll by vertically */public void scrollBy(int x, int y) &#123; scrollTo(mScrollX + x, mScrollY + y);&#125; scrollTo 中直接将传入的新的X轴和Y轴的偏移坐标与当前的偏移坐标比较，如果不同，则直接赋值给了mScrollX和mScrollY，所以调用多次scrollTo只会发生一次位置的变化，而调用多次 scrollBy 则会改变多次，每一次以上一次的偏移坐标为基准。 小明：老师你bb半天，到底怎么样能滚动啊？ 老师：自定义 ViewGroup 重写computeScroll方法，在computeScroll中实现滚动。computeScroll是 View 类中的方法，这个方法是空的，并没有任何实现。这个方法是干什么的呢？字面意思就是计算滚动。我们看看源码： 12345678/** * Called by a parent to request that a child update its values for mScrollX * and mScrollY if necessary. This will typically be done if the child is * animating a scroll using a &#123;@link android.widget.Scroller Scroller&#125; * object. */public void computeScroll() &#123;&#125; 注释意思大概是：如果需要的话，父控件会调用这个方法来请求子控件更新mScrollX和mScrollY的值，如果子控件是使用 Scroller 来执行动画滚动，通常会这样做。 那我们就可以在这个方法里这样写： 1234567@Overridepublic void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); invalidate(); &#125;&#125; 计算滚动偏移量，获取最新的偏移坐标并设置到scrollTo中，以此实现滚动效果。 1234567891011/** * Call this when you want to know the new location. If it returns true, * the animation is not yet finished. */ public boolean computeScrollOffset() &#123; if (mFinished) &#123; return false; &#125; ...更新mCurrX和mCurrY的值... return true;&#125; computeScrollOffset：当你想获取新的坐标点，你就可以调用它更新坐标点，然后调用getCurrX或getCurrY 来获取最新的坐标点。如果返回true表示这个滚动动画还没有完成。 用法比较简单，下面使用 Scroller 实现一个 Demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160public class PullDownViewGroup extends ViewGroup &#123; private static final String TAG = PullDownViewGroup.class.getSimpleName(); /** * 阻尼 */ private static final float DAMPING = 1.5f; private View mContentView; private View mHeaderView; private Scroller mScroller; private int mTouchSlop; /** * 第一次触摸时的坐标 */ private float mDownY; /** * 上一次触发 ACTION_MOVE 时的坐标 */ private float mLastMoveY; /** * 当前坐标 */ private float mCurDownY; /** * 当前坐标和上一次 move 时的距离 */ private float mDeltaY; private boolean isShowHeader = false; public PullDownViewGroup(Context context) &#123; this(context, null); &#125; public PullDownViewGroup(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public PullDownViewGroup(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop(); mScroller = new Scroller(getContext()); &#125; @Override protected void onFinishInflate() &#123; super.onFinishInflate(); int childCount = getChildCount(); if (childCount == 2) &#123; mHeaderView = getChildAt(0); mContentView = getChildAt(1); &#125; else &#123; throw new InflateException("Must have two children."); &#125; &#125; @Override protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); measureChildren(widthMeasureSpec, heightMeasureSpec); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; mHeaderView.layout(0, -mHeaderView.getMeasuredHeight(), mHeaderView.getMeasuredWidth(), 0); mContentView.layout(0, 0, mContentView.getMeasuredWidth(), mContentView.getMeasuredHeight()); &#125; @Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownY = ev.getRawY(); break; case MotionEvent.ACTION_MOVE: mLastMoveY = ev.getRawY(); int mRealTouchSlop = (int) Math.abs(mLastMoveY - mDownY); if (mRealTouchSlop &gt; mTouchSlop) &#123; //当滑动距离大于临界值时，拦截事件（不让事件传递到子控件上），事件传递到本 ViewGroup 的 onTouchEvent。 return true; &#125; break; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: mCurDownY = event.getRawY(); mDeltaY = mCurDownY - mLastMoveY; Log.e(TAG, "mCurDownY:" + mCurDownY + " mLastMoveY:" + mLastMoveY + " mDeltaY:" + mDeltaY + " getScrollY:" + getScrollY()); if ((!isShowHeader &amp;&amp; mDeltaY &lt; 0) || (isShowHeader &amp;&amp; mDeltaY &gt; 0)) &#123; return true; &#125; scrollBy(0, (int) (-mDeltaY / DAMPING)); mLastMoveY = mCurDownY; if (getScrollY() &lt; 0 &amp;&amp; mDeltaY &gt; 0 &amp;&amp; -getScrollY() &gt;= 300 &amp;&amp; !isShowHeader) &#123; //下拉倒临界值，切换到 headerview invalidate(); isShowHeader = true; mScroller.forceFinished(true); int dy = -mHeaderView.getMeasuredHeight() - getScrollY(); Log.d(TAG, "下拉dy: " + dy); mScroller.startScroll(0, getScrollY(), 0, dy); //为什么要减掉getScrollY？因为已经下拉了getScrollY，所以要去掉这么多 return true; &#125; if (getScrollY() &lt; 0 &amp;&amp; mDeltaY &lt; 0 &amp;&amp; mHeaderView.getMeasuredHeight() - Math.abs(getScrollY()) &gt; 300 &amp;&amp; isShowHeader) &#123; invalidate(); isShowHeader = false; mScroller.forceFinished(true); int dy = mContentView.getMeasuredHeight() + getScrollY(); Log.d(TAG, "上拉dy: " + dy); mScroller.startScroll(0, getScrollY(), 0, -getScrollY()); return true; &#125; break; case MotionEvent.ACTION_UP: if ((Math.abs(getScrollY()) &gt;= 300 &amp;&amp; !isShowHeader) || (Math.abs(getScrollY()) &lt;= mHeaderView.getMeasuredHeight() - 300 &amp;&amp; isShowHeader) || !mScroller.isFinished() || mScroller.computeScrollOffset()) &#123; return true; &#125; invalidate(); if (isShowHeader &amp;&amp; mHeaderView.getMeasuredHeight() - Math.abs(getScrollY()) &lt; 300) &#123; mScroller.startScroll(0, getScrollY(), 0, -mHeaderView.getMeasuredHeight() - getScrollY()); &#125; if (!isShowHeader &amp;&amp; Math.abs(getScrollY()) &lt; 300) &#123; mScroller.startScroll(0, getScrollY(), 0, -getScrollY()); &#125; break; &#125; return super.onTouchEvent(event); &#125; @Override public void computeScroll() &#123; if (mScroller.computeScrollOffset()) &#123; scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); invalidate(); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Native 封装Android UI组件]]></title>
      <url>%2F2017%2F01%2F17%2FReact-Native-%E5%B0%81%E8%A3%85Android-UI%E7%BB%84%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[移动APP上用的最多的功能之一可能就是下拉刷新了，今天就用React Native来封装一个基于android-Ultra-Pull-To-Refresh的下拉刷新控件。 封装流程 继承SimpleViewManager或ViewGroupManager创建视图管理器类； 继承ReactPackage创建自定义ReactPackage，重写createNativeModules、createJSModules、createViewManagers这三个方法，返回类型都是 List 类型， 在createViewManagers中添加我们创建好的视图管理器类到集合中，另外两个方法可以返回空 List 集合； 在Application 中添加自定义的 ReactPackage； JS 层封装自定义 UI 控件。 首先继承ViewGroupManager&lt;T&gt;创建一个ReactPtrAndroidManager，ViewGroupManager所需的泛型类型是一个 ViewGroup，在这里就是我们的PtrClassicFrameLayout（我这里直接使用这个库提供的经典的下拉刷新样式），然后重写以下方法： getName：返回这个视图管理器的名称，这个名称将被用于在 JavaScript 中创建 RN 组件时所引用。简单地说就是 JS 层创建的刷新组件将通过这个名字来和 Java 层起到映射关系。 createViewInstance：返回一个和泛型类型一致的 View 实例。在这里就是返回PtrClassicFrameLayout类型的实例。 getCommandsMap：返回想要接收的指令的集合。简单地说就是如果你希望 Java 层接受某个指令，就在这个方法里添加进去，比方说我们这个例子，我想在 Java 层处理自动刷新、刷新完成，那就把自动刷新的Key,Value和刷新完成的 Key,Value添加到 Map 集合中。然后在 JS 层就可以通过调用UIManagerModule类中的dispatchViewManagerCommand方法，传入对应的指令ID 来调用 Java 层的事件。在 RN 中就是这样实现在 JS 层调用 Java 层的代码。 receiveCommand：这个和getCommandsMap是对应的，处理接收到对应指令后的逻辑。我们在getCommandsMap中已经添加了一些指令的集合，并且在 JS 层可以通过dispatchViewManagerCommand来发送对应的指令，然后在 Java 层处理相应的逻辑，那我们怎么知道 JS 层到底发送了什么指令？其实就是在这个方法中来接收 JS 层发出的指令。 addEventEmitters：重写此方法给给定的视图安装自定义事件发射器。如果这个视图需要发射除了基本的触摸事件以外的事件，那么就需要重写这个方法。这个例子中在开始刷新的回调方法中发送一个自定义的事件ptrRefresh给 JS 层， getExportedCustomDirectEventTypeConstants：返回 传递给JS的 定义可以放置在原生视图上的 符合条件的事件 的配置数据的 map 集合(定语比较多(╯‵□′)╯︵┻━┻)， 这应该返回非冒泡直接调度的事件类型。反正我是没看懂。。。以下是个人理解，我们注册了onPtrRefresh事件，这个事件是给JS 层使用的，JS 层在onPtrRefresh中执行刷新的逻辑（请求网络数据等），然后回调给 Java 层。正常NativeApp需要在onRefreshBegin里执行刷新逻辑， 使用 RN 就可以这样在 JS 层上执行刷新逻辑了。JS 层 onPtrRefresh –&gt; Java 层 ptrRefresh –&gt; onRefreshBegin。 addView：为什么要重写 addView 呢？如果看过PtrFrameLayout源码就知道，是在onFinishInflate中 findViewById并初始化contentView和headerView的，可是 RN 根本不走onFinishInflate方法，因为onFinishInflate只是在从 XML 加载完成布局之后才调用（PS:最初我在createViewInstance方法中是inflate XML布局的，打Log是走onFinishInflate的。。。都是泪😭）。并且在调用addView的时候，PtrClassicFrameLayout中已经存在headerView了，在PtrClassicFrameLayout的构造方法中添加的。然后调用父类addView的时候，是从 Index 为0开始添加的，很显然逻辑就不对了，我们要把onFinishInflate中的代码稍微修改一下并且抽出来写成公有方法finishInflateRN，供外部调用。然后我们重写addView 把contentView 添加在 Index 为1的位置，并且调用一下finishInflateRN就好了。 最后就是暴露属性，让 JS 层可以使用这些属性，方法使用ReactProp注解，name就是 JS 的属性，还可以设置一些默认值。 代码片段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class ReactPtrAndroidManager extends ViewGroupManager&lt;PtrClassicFrameLayout&gt; &#123; private static final int REFRESH_COMPLETE = 0; private static final int AUTO_REFRESH = 1; @Override public String getName() &#123; return "RCTPtrAndroid"; &#125; @Override protected PtrClassicFrameLayout createViewInstance(final ThemedReactContext reactContext) &#123; PtrClassicFrameLayout layout = new PtrClassicFrameLayout(reactContext); layout.setLayoutParams(new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)); return layout; &#125; @ReactProp(name = "resistance", defaultFloat = 1.7f) public void setResistance(PtrClassicFrameLayout ptr, float resistance) &#123; ptr.setResistance(resistance); &#125; @ReactProp(name = "durationToCloseHeader", defaultInt = 200) public void setDurationToCloseHeader(PtrClassicFrameLayout ptr, int duration) &#123; ptr.setDurationToCloseHeader(duration); &#125; @ReactProp(name = "durationToClose", defaultInt = 300) public void setDurationToClose(PtrClassicFrameLayout ptr, int duration) &#123; ptr.setDurationToClose(duration); &#125; @ReactProp(name = "ratioOfHeaderHeightToRefresh", defaultFloat = 1.2f) public void setRatioOfHeaderHeightToRefresh(PtrClassicFrameLayout ptr, float ratio) &#123; ptr.setRatioOfHeaderHeightToRefresh(ratio); &#125; @ReactProp(name = "pullToRefresh", defaultBoolean = false) public void setPullToRefresh(PtrClassicFrameLayout ptr, boolean pullToRefresh) &#123; ptr.setPullToRefresh(pullToRefresh); &#125; @ReactProp(name = "keepHeaderWhenRefresh", defaultBoolean = false) public void setKeepHeaderWhenRefresh(PtrClassicFrameLayout ptr, boolean keep) &#123; ptr.setKeepHeaderWhenRefresh(keep); &#125; @ReactProp(name = "pinContent", defaultBoolean = false) public void setPinContent(PtrClassicFrameLayout ptr, boolean pinContent) &#123; ptr.setPinContent(pinContent); &#125; @Nullable @Override public Map&lt;String, Integer&gt; getCommandsMap() &#123; return MapBuilder.of("autoRefresh", AUTO_REFRESH, "refreshComplete", REFRESH_COMPLETE); &#125; @Override public void receiveCommand(PtrClassicFrameLayout root, int commandId, @Nullable ReadableArray args) &#123; switch (commandId) &#123; case AUTO_REFRESH: root.autoRefresh(); break; case REFRESH_COMPLETE: root.refreshComplete(); break; default: break; &#125; &#125; @Override protected void addEventEmitters(final ThemedReactContext reactContext, final PtrClassicFrameLayout view) &#123; view.setLastUpdateTimeRelateObject(this); view.setPtrHandler(new PtrDefaultHandler() &#123; @Override public boolean checkCanDoRefresh(PtrFrameLayout frame, View content, View header) &#123; return checkContentCanBePulledDown(frame, content, header); &#125; @Override public void onRefreshBegin(PtrFrameLayout frame) &#123; reactContext .getNativeModule(UIManagerModule.class) .getEventDispatcher() .dispatchEvent(new PtrEvent(view.getId())); &#125; &#125;); &#125; @Nullable @Override public Map&lt;String, Object&gt; getExportedCustomDirectEventTypeConstants() &#123; return MapBuilder.&lt;String, Object&gt;of( "ptrRefresh", MapBuilder.of("registrationName", "onRefresh")); &#125; @Override public void addView(PtrClassicFrameLayout parent, View child, int index) &#123; super.addView(parent, child, 1); parent.finishInflateRN(); &#125;&#125; 12345678910111213141516public class PtrEvent extends Event&lt;PtrEvent&gt; &#123; public PtrEvent(int viewTag) &#123; super(viewTag); &#125; @Override public String getEventName() &#123; return "ptrRefresh"; &#125; @Override public void dispatch(RCTEventEmitter rctEventEmitter) &#123; rctEventEmitter.receiveEvent(getViewTag(), getEventName(), null); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React, &#123; Component, PropTypes,&#125; from 'react';import &#123; requireNativeComponent, View,&#125; from 'react-native';const UIManager = require('UIManager');const ReactNative = require('ReactNative');const REF_PTR = "ptr_ref";export default class PtrComponent extends Component &#123; constructor(props) &#123; super(props); this._onRefresh = this._onRefresh.bind(this); &#125; _onRefresh() &#123; if (!this.props.handleRefresh) &#123; return; &#125; this.props.handleRefresh(); &#125;; refreshComplete() &#123; UIManager.dispatchViewManagerCommand( ReactNative.findNodeHandle(this.refs[REF_PTR]), 0, null ); &#125; autoRefresh() &#123; let self = this; UIManager.dispatchViewManagerCommand( ReactNative.findNodeHandle(self.refs[REF_PTR]), 1, null ); &#125; render() &#123; // onRefresh 事件对应原生的ptrRefresh事件 return ( &lt;RCTPtrAndroid ref=&#123;REF_PTR&#125; &#123;...this.props&#125; onRefresh=&#123;() =&gt; this._onRefresh()&#125;/&gt; ); &#125;&#125;PtrComponent.name = "RCTPtrAndroid"; //便于调试时显示(可以设置为任意字符串)PtrComponent.propTypes = &#123; handleRefresh: PropTypes.func, resistance: PropTypes.number, durationToCloseHeader: PropTypes.number, durationToClose: PropTypes.number, ratioOfHeaderHeightToRefresh: PropTypes.number, pullToRefresh: PropTypes.bool, keepHeaderWhenRefresh: PropTypes.bool, pinContent: PropTypes.bool, ...View.propTypes,&#125;;const RCTPtrAndroid = requireNativeComponent('RCTPtrAndroid', PtrComponent, &#123;nativeOnly: &#123;onRefresh: true&#125;&#125;); 然后我们就可以使用PtrComponent了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React, &#123; Component, PropTypes,&#125; from 'react';import &#123; Text, View, ToastAndroid, ScrollView,&#125; from 'react-native';import PtrFrame from './component/PtrComponent';export default class Search extends Component &#123; static propTypes = &#123; navigator: PropTypes.object, &#125;; render() &#123; return ( &lt;PtrFrame ref='ptr' handleRefresh=&#123;() =&gt; this._getData()&#125; durationToCloseHeader=&#123;300&#125; durationToClose=&#123;200&#125; resistance=&#123;2&#125; pinContent=&#123;false&#125; ratioOfHeaderHeightToRefresh=&#123;1.2&#125; pullToRefresh=&#123;false&#125; keepHeaderWhenRefresh=&#123;true&#125; style=&#123;&#123;flex: 1&#125;&#125;&gt; &lt;ScrollView style=&#123;&#123;flex: 1, flexDirection: 'column'&#125;&#125;&gt; &lt;View style=&#123;&#123;backgroundColor: '#FFAA55', height: 200&#125;&#125;/&gt; &lt;View style=&#123;&#123;backgroundColor: '#FFAAAA', height: 200&#125;&#125;/&gt; &lt;View style=&#123;&#123;backgroundColor: '#FFAAFF', height: 200&#125;&#125;/&gt; &lt;View style=&#123;&#123;backgroundColor: '#00AAAA', height: 200&#125;&#125;/&gt; &lt;View style=&#123;&#123;backgroundColor: '#00AA99', height: 200&#125;&#125;/&gt; &lt;View style=&#123;&#123;backgroundColor: '#FF99AA', height: 200&#125;&#125;/&gt; &lt;/ScrollView&gt; &lt;/PtrFrame&gt; ); &#125;; _getData() &#123; ToastAndroid.show("refreshing", ToastAndroid.SHORT); this.timer = setTimeout(() =&gt; &#123; this.refs.ptr.refreshComplete(); &#125;, 2500); &#125;; componentWillUnmount() &#123; this.timer &amp;&amp; clearTimeout(this.timer); &#125;&#125; 效果图 项目地址https://github.com/panda912/RNAndroidPullToRefresh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android L 使用 ViewOutlineProvider 裁剪 View]]></title>
      <url>%2F2017%2F01%2F12%2FAndroid-L-%E4%BD%BF%E7%94%A8-ViewOutlineProvider-%E8%A3%81%E5%89%AA-View%2F</url>
      <content type="text"><![CDATA[Android 5.0的 View 类中新增了 setOutlineProvider(ViewOutlineProvider provider) 方法，注释如下： Sets the {@link ViewOutlineProvider} of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping. The default ViewOutlineProvider, {@link ViewOutlineProvider#BACKGROUND}, queries the Outline from the View’s background drawable, via {@link Drawable#getOutline(Outline)}. Changing the outline provider with this method allows this behavior to be overridden. If the ViewOutlineProvider is null, if querying it for an outline returns false, or if the produced Outline is {@link Outline#isEmpty()}, shadows will not be cast. Only outlines that return true from {@link Outline#canClip()} may be used for clipping. @see #setClipToOutline(boolean) @see #getClipToOutline() @see #getOutlineProvider() 那么我们可以用它来把 View 裁剪成一些特定(圆形、矩形、圆角矩形)的形状： 1234567view.setOutlineProvider(new ViewOutlineProvider() &#123; @Override public void getOutline(View view, Outline outline) &#123; outline.setRoundRect(0, 0, view.getWidth(), view.getHeight(), 30); &#125;&#125;);view.setClipToOutline(true); 也可以用来设置投影，但是投影的形状只能是凸多边形，为什么？看源码： 123456789101112131415161718/** * Sets the Constructs an Outline from a * &#123;@link android.graphics.Path#isConvex() convex path&#125;. */public void setConvexPath(@NonNull Path convexPath) &#123; if (convexPath.isEmpty()) &#123; setEmpty(); return; &#125; //如果不是凸多边形，会抛异常 if (!convexPath.isConvex()) &#123; throw new IllegalArgumentException("path must be convex"); &#125; mMode = MODE_CONVEX_PATH; mPath.set(convexPath); mRect.setEmpty(); mRadius = RADIUS_UNDEFINED;&#125; 123456789101112131415view.setElevation(5);view.setOutlineProvider(new ViewOutlineProvider() &#123; @Override public void getOutline(View view, Outline outline) &#123; //你可以用 Path 指定任何的形状，前提是凸多边形 //这里设置投影的位置从右下角开始，投影形状是矩形 Path path = new Path(); path.moveTo(view.getWidth(), view.getHeight()); path.lineTo(view.getWidth(), view.getHeight() * 2); path.lineTo(view.getWidth() * 2, view.getHeight() * 2); path.lineTo(view.getWidth() * 2, view.getHeight()); path.close(); outline.setConvexPath(path); &#125;&#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用属性动画实现进度条效果]]></title>
      <url>%2F2016%2F12%2F30%2F%E4%BD%BF%E7%94%A8%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[参考链接：http://blog.csdn.net/AndroidMsky/article/details/50239447 最近项目中要做一个显示进度的效果，设计给了我们每个阶段的切图，只要根据数据显示不同的图片就可以了，后来空闲的时候就想着把它做成动态的效果，以前无意间看到上面的文章，正好在这里用到，实现方式比较简单，就三层View，最底层是绿色的View，中间一层是灰色的View，最上层就是一个空心的ImageView，使用属性动画控制中间灰色的View向右平移，最底层绿色就会显示出来，从而实现动态进度条的效果。至于底部的文字，就是 LinearLayout 四等分，在addUpdateListener中获取动画当前的value，动态设置文字的颜色。 代码片段：12345678910111213141516171819202122// mProgressMaskView 中间灰色遮罩层View// mProgressDrawableWidth 进度条的宽度// state 服务器返回的字段 1、2、3、4，对应每一个阶段final int state = StringConversionUtil.parseInt(obj.ob_state, 1);if (mProgressAnimator == null) &#123; mProgressAnimator = ObjectAnimator.ofFloat(mProgressMaskView, "translationX", 0, mProgressDrawableWidth * state / 4); mProgressAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float value = (float) animation.getAnimatedValue(); int index = (int) (value / (mProgressDrawableWidth / 4)); //设置底部文字的颜色 ((TextView) mProgressInfoLL.getChildAt(Math.min(index, state - 1))).setTextColor(getResources().getColor(R.color.toolbar_green)); &#125; &#125;); mProgressAnimator.setDuration(1000);&#125; else &#123; mProgressAnimator.setFloatValues(0, mProgressDrawableWidth * state / 4);&#125;if (!mProgressAnimator.isRunning()) &#123; mProgressAnimator.start();&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Drawable 之 LevelListDrawable]]></title>
      <url>%2F2016%2F12%2F23%2FAndroid-Drawable-%E4%B9%8B-LevelListDrawable%2F</url>
      <content type="text"><![CDATA[本文演示使用LevelListDrawable结合android-Ultra-Pull-To-Refresh实现同程旅游App 的首页下拉刷新效果，Demo使用到的图片资源是解压缩同程App 取到的。 效果分析：仔细观察这个下拉效果不难发现，下拉的时候其实就是根据下拉的距离显示不同的图片，刷新的时候就是显示一个loading 动画。 代码目录： 代码片段：tc_pull.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="true"&gt; &lt;item android:drawable="@drawable/loading_home_1" android:maxLevel="0" /&gt; &lt;item android:drawable="@drawable/loading_home_2" android:maxLevel="1" /&gt; &lt;item android:drawable="@drawable/loading_home_3" android:maxLevel="2" /&gt; &lt;item android:drawable="@drawable/loading_home_4" android:maxLevel="3" /&gt; &lt;item android:drawable="@drawable/loading_home_5" android:maxLevel="4" /&gt; &lt;item android:drawable="@drawable/loading_home_6" android:maxLevel="5" /&gt; &lt;item android:drawable="@drawable/loading_home_7" android:maxLevel="6" /&gt; &lt;item android:drawable="@drawable/loading_home_8" android:maxLevel="7" /&gt; &lt;item android:drawable="@drawable/loading_home_9" android:maxLevel="8" /&gt; &lt;item android:drawable="@drawable/loading_home_10" android:maxLevel="9" /&gt; &lt;item android:drawable="@drawable/loading_home_11" android:maxLevel="10" /&gt; &lt;item android:drawable="@drawable/loading_home_12" android:maxLevel="11" /&gt; &lt;item android:drawable="@drawable/loading_home_13" android:maxLevel="12" /&gt; &lt;item android:drawable="@drawable/loading_home_14" android:maxLevel="13" /&gt; &lt;item android:drawable="@drawable/loading_home_15" android:maxLevel="14" /&gt; &lt;item android:drawable="@drawable/loading_home_16" android:maxLevel="15" /&gt; &lt;item android:drawable="@drawable/loading_home_17" android:maxLevel="16" /&gt; &lt;item android:drawable="@drawable/loading_home_18" android:maxLevel="17" /&gt; &lt;item android:drawable="@drawable/loading_home_19" android:maxLevel="18" /&gt; &lt;item android:drawable="@drawable/loading_home_20" android:maxLevel="19" /&gt; &lt;item android:drawable="@drawable/loading_home_21" android:maxLevel="20" /&gt; &lt;item android:drawable="@drawable/loading_home_22" android:maxLevel="21" /&gt; &lt;item android:drawable="@drawable/loading_home_23" android:maxLevel="22" /&gt;&lt;/level-list&gt; tc_loading.xml12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/loop_home_01" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_01" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_02" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_03" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_04" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_05" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_06" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_07" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_08" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_09" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_10" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_11" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_12" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_13" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_14" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_15" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_16" android:duration="70" /&gt; &lt;item android:drawable="@drawable/loop_home_17" android:duration="70" /&gt;&lt;/animation-list&gt; TCPtrHeader.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TCPtrHeader extends FrameLayout implements PtrUIHandler &#123; public static final String TAG = TCPtrHeader.class.getSimpleName(); private ImageView mPullIV; public TCPtrHeader(Context context) &#123; this(context, null); &#125; public TCPtrHeader(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public TCPtrHeader(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; mPullIV = new ImageView(getContext()); mPullIV.setPadding(0, 30, 0, 0); mPullIV.setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT)); mPullIV.setImageResource(R.drawable.tc_pull); mPullIV.setScaleType(ImageView.ScaleType.FIT_CENTER); addView(mPullIV); &#125; @Override public void onUIReset(PtrFrameLayout frame) &#123; &#125; @Override public void onUIRefreshPrepare(PtrFrameLayout frame) &#123; &#125; @Override public void onUIRefreshBegin(PtrFrameLayout frame) &#123; mPullIV.setImageResource(R.drawable.tc_loading); AnimationDrawable drawable = (AnimationDrawable) mPullIV.getDrawable(); drawable.start(); &#125; @Override public void onUIRefreshComplete(PtrFrameLayout frame) &#123; mPullIV.setImageResource(R.drawable.tc_pull); &#125; @Override public void onUIPositionChange(PtrFrameLayout frame, boolean isUnderTouch, byte status, PtrIndicator ptrIndicator) &#123; final int offsetToRefresh = frame.getOffsetToRefresh(); final int currentPos = ptrIndicator.getCurrentPosY(); final int imgLevel = currentPos / (offsetToRefresh / 23); mPullIV.setImageLevel(Math.min(imgLevel, 22)); &#125;&#125; 总结：本文主要是介绍LevelListDrawable的基本用法，说实话我之前是不知道有这个东西的，其实 Android 给我们提供了许多API，我们要善于利用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TabLayout 显示更多 拖拽排序]]></title>
      <url>%2F2016%2F10%2F28%2FTabLayout-%E6%98%BE%E7%A4%BA%E6%9B%B4%E5%A4%9A-%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[#实现思路点击”更多”显示包含RecyclerView的PopupWindow，只要让RecyclerView选中item的position和ViewPager的currentItem对应就好了；当RecyclerView拖拽排序之后只要控制好当前选中的item的position的逻辑就好了。 不管怎么拖拽排序，只要当前选中的item的position没有变，则排序之后选中的position还是原position；如果排序之后当前选中的item的position发生变化，则根据具体情况+1或-1；如果当前拖拽的是选中的item，则拖拽排序之后当前选中item的position就是拖拽之后的position。 当Viewpager切换的时候，相应改变 RecyclerView适配器中记录的当前选中的item的值mCurrentItem，并更新适配器。 12345@Overridepublic void onPageSelected(int position) &#123; mRVAdapter.setCurrentItem(position); mRVAdapter.notifyDataSetChanged();&#125; 继承ItemTouchHelper.Callback重写其方法，处理拖拽的效果，并让适配器实现OnItemMoveCallback接口，把拖拽的相关逻辑放到适配器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class TabItemTouchCallback extends ItemTouchHelper.Callback &#123; @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; if (recyclerView.getLayoutManager() instanceof GridLayoutManager) &#123; final int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT; final int swipeFlags = 0; return makeMovementFlags(dragFlags, swipeFlags); &#125; else if (recyclerView.getLayoutManager() instanceof LinearLayoutManager) &#123; final int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; final int swipeFlags = 0; return makeMovementFlags(dragFlags, swipeFlags); &#125; else &#123; return 0; &#125; &#125; @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; int fromPosition = viewHolder.getAdapterPosition(); int toPosition = target.getAdapterPosition(); if (mOnItemMoveCallback != null) &#123; mOnItemMoveCallback.onMove(fromPosition, toPosition); &#125; return true; &#125; @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; if (mOnItemMoveCallback != null) &#123; mOnItemMoveCallback.onSwiped(viewHolder.getAdapterPosition()); &#125; &#125; @Override public void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) &#123; if (actionState == ItemTouchHelper.ACTION_STATE_SWIPE) &#123; viewHolder.itemView.setTranslationX(dX); &#125; else &#123; super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive); &#125; &#125; @Override public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123; super.onSelectedChanged(viewHolder, actionState); &#125; @Override public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; super.clearView(recyclerView, viewHolder); mOnItemMoveCallback.onFinished(); &#125; private OnItemMoveCallback mOnItemMoveCallback; public void setOnItemMoveCallback(OnItemMoveCallback callback) &#123; mOnItemMoveCallback = callback; &#125; public interface OnItemMoveCallback &#123; void onMove(int fromPosition, int toPosition); void onSwiped(int position); void onFinished(); &#125;&#125; 重点看onMove方法： 12345public abstract int getMovementFlags(RecyclerView recyclerView, ViewHolder viewHolder);public abstract boolean onMove(RecyclerView recyclerView, ViewHolder viewHolder, ViewHolder target);public abstract void onSwiped(ViewHolder viewHolder, int direction);public void onSelectedChanged(ViewHolder viewHolder, int actionState) &#123;&#125;public void clearView(RecyclerView recyclerView, ViewHolder viewHolder) &#123;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义标签选择器控件]]></title>
      <url>%2F2016%2F10%2F27%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8%E6%8E%A7%E4%BB%B6%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[shape中设置padding无效解决方案]]></title>
      <url>%2F2016%2F10%2F20%2Fshape%E4%B8%AD%E8%AE%BE%E7%BD%AEpadding%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[最近在写布局的时候，给LinearLayout添加分割线，并且想让分割线有上下边距，于是就自定义一个shape： 12345678&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;size android:height="@dimen/line_height" /&gt; &lt;solid android:color="@color/main_line" /&gt; &lt;padding android:bottom="10dp" android:top="10dp" /&gt;&lt;/shape&gt; 可是事与愿违，实际效果并没有上下边距。 解决方法： 把shape放在layer-list的item中，直接在item的节点下设置top和bottom： 12345678910&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:bottom="10dp" android:top="10dp"&gt; &lt;shape android:shape="rectangle"&gt; &lt;size android:height="@dimen/line_height" /&gt; &lt;solid android:color="@color/main_line" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SurfaceView基本用法]]></title>
      <url>%2F2016%2F10%2F18%2FSurfaceView%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[SurfaceView一半多用于游戏开发，或者类似大转盘，时钟控件等动态实时更新的View，因为它要求在子线程中绘制，而不会阻塞主线程。 自定义View继承SurfaceView并且实现SurfaceHolder.Callback接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * A client may implement this interface to receive information about * changes to the surface. When used with a &#123;@link SurfaceView&#125;, the * Surface being held is only available between calls to * &#123;@link #surfaceCreated(SurfaceHolder)&#125; and * &#123;@link #surfaceDestroyed(SurfaceHolder)&#125;. The Callback is set with * &#123;@link SurfaceHolder#addCallback SurfaceHolder.addCallback&#125; method. */public interface Callback &#123; /** * This is called immediately after the surface is first created. * Implementations of this should start up whatever rendering code * they desire. Note that only one thread can ever draw into * a &#123;@link Surface&#125;, so you should not draw into the Surface here * if your normal rendering will be in another thread. * * @param holder The SurfaceHolder whose surface is being created. */ public void surfaceCreated(SurfaceHolder holder); /** * This is called immediately after any structural changes (format or * size) have been made to the surface. You should at this point update * the imagery in the surface. This method is always called at least * once, after &#123;@link #surfaceCreated&#125;. * * @param holder The SurfaceHolder whose surface has changed. * @param format The new PixelFormat of the surface. * @param width The new width of the surface. * @param height The new height of the surface. */ public void surfaceChanged(SurfaceHolder holder, int format, int width, int height); /** * This is called immediately before a surface is being destroyed. After * returning from this call, you should no longer try to access this * surface. If you have a rendering thread that directly accesses * the surface, you must ensure that thread is no longer touching the * Surface before returning from this function. * * @param holder The SurfaceHolder whose surface is being destroyed. */ public void surfaceDestroyed(SurfaceHolder holder);&#125; surfaceCreated在surface第一次创建的时候会调用，一般在该方法中创建并启动绘制线程； surfaceChanged在surface发生变化时会调用； surfaceDestroyed在surface被销毁的时候调用，一般在这里停止绘制线程。 它会在surface被销毁之前立即调用，当被调用之后，就不不应该再试图访问surface。如果你有一个渲染线程直接访问surface，你应该确保这个线程在该方法调用之前不再有关联。 我们可以通过SurfaceView中getHolder()来获取SurfaceHolder，再通过SurfaceHolder的lockCanvas()来获取Canvas， 1public Canvas lockCanvas(Rect dirty); 脏矩形，只刷新该区域，优化性能，注意双缓冲的问题。 获取完画布就可以做绘制的事情了，绘制完成之后调用要SurfaceHolder的unlockCanvasAndPost(Canvas canvas)提交画布。 时钟Demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226public class Clock extends SurfaceView implements SurfaceHolder.Callback &#123; private final Object lock = new Object(); private SurfaceHolder mSurfaceHolder; private DrawThread mDrawThread; /** * 面板 */ private Paint mPanelPaint; /** * 刻度 */ private Paint mScalePaint; /** * 数字 */ private Paint mTextPaint; /** * 时针 */ private Paint mHourPaint; /** * 分针 */ private Paint mMinutePaint; /** * 秒针 */ private Paint mSecondPaint; private int mRadius; public Clock(Context context) &#123; this(context, null); &#125; public Clock(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public Clock(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mSurfaceHolder = this.getHolder(); mSurfaceHolder.addCallback(this); //面板 mPanelPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPanelPaint.setColor(Color.RED); //刻度 mScalePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mScalePaint.setColor(Color.argb(130, 255, 255, 255)); mTextPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mTextPaint.setColor(Color.WHITE); mTextPaint.setTextSize(40); mTextPaint.setTextAlign(Paint.Align.CENTER); //时针 mHourPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mHourPaint.setColor(Color.WHITE); //分针 mMinutePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mMinutePaint.setColor(Color.argb(200, 255, 255, 255)); //秒针 mSecondPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mSecondPaint.setStrokeWidth(2); mSecondPaint.setColor(Color.GRAY); setFocusable(false); setFocusableInTouchMode(false); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mDrawThread = new DrawThread(); mDrawThread.setRun(true); mDrawThread.start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mDrawThread.setRun(false); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); mRadius = Math.min(getMeasuredWidth(), getMeasuredHeight()) / 2; &#125; private class DrawThread extends Thread &#123; private static final float RATIO = 6 / 7f; private boolean isRun; @Override public void run() &#123; while (isRun) &#123; synchronized (lock) &#123; Canvas canvas = mSurfaceHolder.lockCanvas(); if (canvas != null) &#123; long start = System.currentTimeMillis(); doDraw(canvas); mSurfaceHolder.unlockCanvasAndPost(canvas); long end = System.currentTimeMillis(); long duration = end - start; if (duration &lt; 1000) &#123; try &#123; Thread.sleep(1000 - duration); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; /** * 画面板 * * @param canvas */ private void doDraw(final Canvas canvas) &#123; //清屏 canvas.drawColor(Color.RED); //面板 canvas.drawCircle(mRadius, mRadius, mRadius, mPanelPaint); //刻度 for (int i = 1, scaleSize = 12 * 5 * 5; i &lt;= scaleSize; i++) &#123; canvas.rotate(1.2f, mRadius, mRadius); if (i % 25 == 0) &#123; mScalePaint.setStrokeWidth(4); mScalePaint.setColor(Color.argb(150, 255, 255, 255)); canvas.drawLine(mRadius, 0, mRadius, 50, mScalePaint); &#125; else if (i % 5 == 0) &#123; mScalePaint.setStrokeWidth(3); mScalePaint.setColor(Color.argb(120, 255, 255, 255)); canvas.drawLine(mRadius, 0, mRadius, 30, mScalePaint); &#125; else &#123; mScalePaint.setStrokeWidth(2); mScalePaint.setColor(Color.argb(100, 255, 255, 255)); canvas.drawLine(mRadius, 0, mRadius, 18, mScalePaint); &#125; &#125; RectF f = new RectF(); Calendar calendar = Calendar.getInstance(); int hour = calendar.get(Calendar.HOUR_OF_DAY); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); canvas.save(); canvas.rotate(30 * (hour + (minute + second / 60) / 60f), mRadius, mRadius); canvas.drawRoundRect(new RectF(mRadius - 5, mRadius / 3, mRadius + 5, mRadius + 20), 10, 10, mHourPaint); canvas.restore(); canvas.save(); canvas.rotate(6 * (minute + second / 60f), mRadius, mRadius); canvas.drawRoundRect(new RectF(mRadius - 3f, 60, mRadius + 3f, mRadius + 20), 10, 10, mMinutePaint); canvas.restore(); canvas.save(); canvas.rotate(6 * second, mRadius, mRadius); mSecondPaint.setStyle(Paint.Style.FILL); canvas.drawRect(new RectF(mRadius - 2, 50, mRadius + 2, mRadius + 30), mSecondPaint); canvas.restore(); for (int i = 1; i &lt;= 12; i++) &#123; float width = mTextPaint.measureText(String.valueOf(i)); double x = mRadius + (mRadius - 50) * Math.cos((i * 30 - 90) * Math.PI / 180d); double y = mRadius + (mRadius - 50) * Math.sin((i * 30 - 90) * Math.PI / 180d) - width / 2 * Math.sin(i * 30); canvas.drawText(String.valueOf(i), (float) x, (float) y, mTextPaint); &#125; ////////////////////////////////////////////////////////////////////////////////// //x1 = x0 + r * cos(angle * pi / 180) //y1 = y0 + r * sin(angle * pi / 180)// double x = mRadius + (mRadius - 60) * Math.cos((second * 6 - 90) * Math.PI / 180d);// double y = mRadius + (mRadius - 60) * Math.sin((second * 6 - 90) * Math.PI / 180d);//// double tailX = x - (x - mRadius) / RATIO;// double tailY = y - (y - mRadius) / RATIO;//// Path path = new Path();// mSecondPaint.setStyle(Paint.Style.STROKE);// path.moveTo((float) tailX, (float) tailY);// path.lineTo((float) x, (float) y);// canvas.drawPath(path, mSecondPaint); //中心圆点 mSecondPaint.setStyle(Paint.Style.FILL); canvas.drawCircle(mRadius, mRadius, 6, mSecondPaint); &#125; void setRun(boolean isRun) &#123; this.isRun = isRun; &#125; &#125; public void setRun(boolean isRun) &#123; mDrawThread.setRun(isRun); &#125; public void setRadius(int radius) &#123; this.mRadius = radius; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仿同程旅游app产品详情页，实现scrollview中tab顶部悬停效果]]></title>
      <url>%2F2016%2F10%2F14%2F%E4%BB%BF%E5%90%8C%E7%A8%8B%E6%97%85%E6%B8%B8app%E4%BA%A7%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5%EF%BC%8C%E5%AE%9E%E7%8E%B0scrollview%E4%B8%ADtab%E9%A1%B6%E9%83%A8%E6%82%AC%E5%81%9C%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[#效果图 #实现方式1.在顶部放一个与scrollview中相同布局的浮动view，控制显示/隐藏； 2.view.setTranslationY(translationY)； 如果这个浮动的view有多种状态（类似tab切换这种），那么方式1就比较麻烦，要同步状态，所以本文是用方式2实现的。 #代码分析自定义属性，可以对照下图理解： 123456789101112&lt;declare-styleable name="FloatTabScrollView"&gt; &lt;attr name="top_layout" format="reference" /&gt; &lt;attr name="page1_layout" format="reference" /&gt; &lt;attr name="page2_layout" format="reference" /&gt; &lt;attr name="page3_layout" format="reference" /&gt; &lt;attr name="bottom_layout" format="reference" /&gt; &lt;attr name="tab1_title" format="string" /&gt; &lt;attr name="tab2_title" format="string" /&gt; &lt;attr name="tab3_title" format="string" /&gt; &lt;attr name="selected_tab_color" format="color" /&gt; &lt;attr name="unselected_tab_color" format="color" /&gt;&lt;/declare-styleable&gt; 在自定义的FloatTabScrollView的构造方法中inflate一个布局文件和获取自定义属性: 123456789101112131415161718192021222324252627282930313233343536373839public FloatTabScrollView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mContext = context; inflate(context, R.layout.layout_float_tab_scrollview, this); TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.FloatTabScrollView, 0, 0); if (ta != null) &#123; if (ta.hasValue(R.styleable.FloatTabScrollView_tab1_title)) &#123; mTabTitle1 = ta.getString(R.styleable.FloatTabScrollView_tab1_title); &#125; if (ta.hasValue(R.styleable.FloatTabScrollView_tab2_title)) &#123; mTabTitle2 = ta.getString(R.styleable.FloatTabScrollView_tab2_title); &#125; if (ta.hasValue(R.styleable.FloatTabScrollView_tab3_title)) &#123; mTabTitle3 = ta.getString(R.styleable.FloatTabScrollView_tab3_title); &#125; if (ta.hasValue(R.styleable.FloatTabScrollView_top_layout)) &#123; mTopLayoutId = ta.getResourceId(R.styleable.FloatTabScrollView_top_layout, 0); &#125; if (ta.hasValue(R.styleable.FloatTabScrollView_page1_layout)) &#123; mPage1LayoutId = ta.getResourceId(R.styleable.FloatTabScrollView_page1_layout, 0); &#125; if (ta.hasValue(R.styleable.FloatTabScrollView_page2_layout)) &#123; mPage2LayoutId = ta.getResourceId(R.styleable.FloatTabScrollView_page2_layout, 0); &#125; if (ta.hasValue(R.styleable.FloatTabScrollView_page3_layout)) &#123; mPage3LayoutId = ta.getResourceId(R.styleable.FloatTabScrollView_page3_layout, 0); &#125; if (ta.hasValue(R.styleable.FloatTabScrollView_bottom_layout)) &#123; mBottomLayoutId = ta.getResourceId(R.styleable.FloatTabScrollView_bottom_layout, 0); &#125; if (ta.hasValue(R.styleable.FloatTabScrollView_tabline_color)) &#123; tabLineColor = ta.getColor(R.styleable.FloatTabScrollView_tabline_color, 0xFFFF4081); &#125; ta.recycle(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/nestedscrollview" android:layout_width="match_parent" android:layout_height="match_parent" android:overScrollMode="never"&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;FrameLayout android:id="@+id/fl_top" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;!--给tab占位的view--&gt; &lt;View android:id="@+id/view_tab_holder" android:layout_width="match_parent" android:layout_height="45dp" /&gt; &lt;FrameLayout android:id="@+id/fl_page1" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;FrameLayout android:id="@+id/fl_page2" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;FrameLayout android:id="@+id/fl_page3" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;FrameLayout android:id="@+id/fl_bottom" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt; &lt;!--tab--&gt; &lt;LinearLayout android:id="@+id/ll_tab" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@android:color/white" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="43dp" android:orientation="horizontal"&gt; &lt;TextView android:id="@+id/tv_tab1" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" tools:text="商品详情" /&gt; &lt;TextView android:id="@+id/tv_tab2" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" tools:text="商品参数" /&gt; &lt;TextView android:id="@+id/tv_tab3" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:gravity="center" tools:text="商品推荐" /&gt; &lt;/LinearLayout&gt; &lt;View android:id="@+id/view_tab_line" android:layout_width="120dp" android:layout_height="2dp" android:background="#FFFF4081" /&gt; &lt;/LinearLayout&gt; &lt;/FrameLayout&gt;&lt;/android.support.v4.widget.NestedScrollView&gt; ScrollView下的子布局必须是FrameLayout或者RelativeLayout，在tab的位置放一个占位的View，如果占位view没有到达顶部，则让tab一直显示在占位view的位置，如果占位view到达了顶部，则让tab“固定”在顶部，为什么“固定”要加引号，其实并不是固定，tab一直在ScrollView中滚动，只是相对静止而已。 然后在onFinishInflate中加载每一块区域的布局文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Overrideprotected void onFinishInflate() &#123; super.onFinishInflate(); mTopContainerFL = (FrameLayout) findViewById(R.id.fl_top); mPage1ContainerFL = (FrameLayout) findViewById(R.id.fl_page1); mPage2ContainerFL = (FrameLayout) findViewById(R.id.fl_page2); mPage3ContainerFL = (FrameLayout) findViewById(R.id.fl_page3); mBottomContainerFL = (FrameLayout) findViewById(R.id.fl_bottom); inflate(mContext, mTopLayoutId, mTopContainerFL); inflate(mContext, mPage1LayoutId, mPage1ContainerFL); inflate(mContext, mPage2LayoutId, mPage2ContainerFL); inflate(mContext, mPage3LayoutId, mPage3ContainerFL); inflate(mContext, mBottomLayoutId, mBottomContainerFL); mTabHolderView = findViewById(R.id.view_tab_holder); mTabLL = (LinearLayout) findViewById(R.id.ll_tab); mTabLine = findViewById(R.id.view_tab_line); mTabLine.setBackgroundColor(tabLineColor); mTabTV1 = (TextView) findViewById(R.id.tv_tab1); mTabTV2 = (TextView) findViewById(R.id.tv_tab2); mTabTV3 = (TextView) findViewById(R.id.tv_tab3); mTabTV1.setText(mTabTitle1); mTabTV2.setText(mTabTitle2); mTabTV3.setText(mTabTitle3); mTabTV1.setOnClickListener(this); mTabTV2.setOnClickListener(this); mTabTV3.setOnClickListener(this); getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; setTabViewPosition(0); if (bGradient) &#123; mToolbar.getBackground().setAlpha(MIN_ALPHA); &#125; getViewTreeObserver().removeGlobalOnLayoutListener(this); &#125; &#125;);&#125; 覆写onScrollChanged方法来平移tab的位置： 1234567891011@Overrideprotected void onScrollChanged(int scrollX, int scrollY, int oldScrollX, int oldScrollY) &#123; super.onScrollChanged(scrollX, scrollY, oldScrollX, oldScrollY); setTabViewPosition(scrollY); if (bGradient) &#123; float alpha = scrollY / (float) (mTabHolderView.getTop() - mToolbar.getHeight()) * MAX_ALPHA; mToolbar.getBackground().setAlpha(Math.min((int) alpha, MAX_ALPHA)); &#125;&#125; 1234567891011121314151617181920private void setTabViewPosition(int scrollY) &#123; if (scrollY &lt;= mPage3ContainerFL.getTop() + mPage3ContainerFL.getHeight() - mTabLL.getHeight()) &#123; //设置tabview在scrollview中的位置 mTabLL.setTranslationY(Math.max(scrollY + (mToolbar != null ? mToolbar.getHeight() : 0), mTabHolderView.getTop())); //滚动过程中切换tab的选中状态 if (scrollY &lt; mPage2ContainerFL.getTop() - mTabLL.getHeight() - (mToolbar != null ? mToolbar.getHeight() : 0)) &#123; selectTab(0); &#125; else if (scrollY &gt;= mPage2ContainerFL.getTop() - mTabLL.getHeight() - (mToolbar != null ? mToolbar.getHeight() : 0) &amp;&amp; scrollY &lt; mPage3ContainerFL.getTop() - mTabLL.getHeight() - (mToolbar != null ? mToolbar.getHeight() : 0)) &#123; selectTab(1); &#125; else if (scrollY &gt;= mPage3ContainerFL.getTop() - mTabLL.getHeight() - (mToolbar != null ? mToolbar.getHeight() : 0)) &#123; selectTab(2); &#125; &#125; else &#123; //超过最大高度之后,把tabview设置在原始位置,,,,,,也可以不设置 mTabLL.setTranslationY(mTabHolderView.getTop()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839private void selectTab(int index) &#123; if (mTabLineAnimator == null) &#123; mTabLineAnimator = new ValueAnimator(); mTabLineAnimator.setDuration(DEFAULT_DURATION); mTabLineAnimator.setInterpolator(new FastOutSlowInInterpolator()); mTabLineAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; mTabLine.setTranslationX((int) animation.getAnimatedValue()); &#125; &#125;); &#125; int curTabLineX = (int) mTabLine.getX(); int needTabLineX = 0; switch (index) &#123; case 0: needTabLineX = 0; break; case 1: needTabLineX = mTabLL.getWidth() / 3; break; case 2: needTabLineX = mTabLL.getWidth() / 3 * 2; break; default: break; &#125; if (curTabLineX == needTabLineX) &#123; return; &#125; mTabLineAnimator.setIntValues(curTabLineX, needTabLineX); if (!mTabLineAnimator.isRunning()) &#123; mTabLineAnimator.start(); &#125;&#125; #项目地址https://github.com/panda912/FloatTabScrollView]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gradle使用exclude移除重复依赖]]></title>
      <url>%2F2016%2F09%2F20%2Fgradle%E4%BD%BF%E7%94%A8exclude%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E4%BE%9D%E8%B5%96%2F</url>
      <content type="text"><![CDATA[exclude+— com.android.support:design:24.2.1 | +— com.android.support:support-v4:24.2.1 (*) | +— com.android.support:appcompat-v7:24.2.1 (*) | \ — com.android.support:recyclerview-v7:24.2.1 | +— com.android.support:support-annotations:24.2.1 | +— com.android.support:support-compat:24.2.1 (*) | \ — com.android.support:support-core-ui:24.2.1 (*) 上面是com.android.support:design:24.2.1的依赖关系，如果项目已经依赖了com.android.support:support-v4:24.2.1，那么就可以吧design包中的support-v4移除。 compile(&apos;com.android.support:design:24.2.1&apos;) { exclude group: &apos;com.android.support&apos;, module: &apos;support-v4&apos; } group对应com.android.support， module对应support-v4，如果只写group，不写module，那么将会移除design包下所有与group对应的包。 transitive用于自动处理子依赖项。默认为 true，gradle 自动添加子依赖项；设置为 false，则需要手动添加每个依赖项。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gradle常用命令]]></title>
      <url>%2F2016%2F09%2F20%2Fgradle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[查看依赖树查看所有依赖树gradle -q app:dependencies 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708panda:Gank panda$ gradle -q app:dependencies------------------------------------------------------------Project :app------------------------------------------------------------_debugAndroidTestAnnotationProcessor - ## Internal use, do not manually configure ##No dependencies_debugAndroidTestApk - ## Internal use, do not manually configure ##No dependencies_debugAndroidTestCompile - ## Internal use, do not manually configure ##No dependencies_debugAnnotationProcessor - ## Internal use, do not manually configure ##No dependencies_debugApk - ## Internal use, do not manually configure ##+--- io.realm:realm-annotations:2.0.0+--- com.android.support:appcompat-v7:24.2.1 -&gt; 25.0.0| +--- com.android.support:support-v4:25.0.0| | +--- com.android.support:support-compat:25.0.0| | | \--- com.android.support:support-annotations:25.0.0| | +--- com.android.support:support-media-compat:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-core-utils:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-core-ui:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | \--- com.android.support:support-fragment:25.0.0| | +--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-media-compat:25.0.0 (*)| | +--- com.android.support:support-core-ui:25.0.0 (*)| | \--- com.android.support:support-core-utils:25.0.0 (*)| +--- com.android.support:support-vector-drawable:25.0.0| | \--- com.android.support:support-compat:25.0.0 (*)| \--- com.android.support:animated-vector-drawable:25.0.0| \--- com.android.support:support-vector-drawable:25.0.0 (*)+--- com.android.support:recyclerview-v7:25.0.0| +--- com.android.support:support-annotations:25.0.0| +--- com.android.support:support-compat:25.0.0 (*)| \--- com.android.support:support-core-ui:25.0.0 (*)+--- com.github.CymChad:BaseRecyclerViewAdapterHelper:2.2.9+--- com.youzan:titan:0.2.5| \--- com.android.support:recyclerview-v7:23.3.0 -&gt; 25.0.0 (*)+--- com.android.support:customtabs:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.squareup.okhttp3:logging-interceptor:3.4.1+--- com.squareup.retrofit2:retrofit:2.1.0+--- com.squareup.retrofit2:converter-gson:2.1.0| \--- com.google.code.gson:gson:2.7+--- com.squareup.retrofit2:adapter-rxjava:2.1.0| \--- io.reactivex:rxjava:1.1.5 -&gt; 1.1.6+--- jp.wasabeef:picasso-transformations:2.1.0+--- io.reactivex:rxandroid:1.2.1+--- xiaofei.library:hermes-eventbus:0.2.0| +--- xiaofei.library:concurrent-utils:0.1.4| +--- org.greenrobot:eventbus:3.0.0| \--- xiaofei.library:hermes:0.6.1+--- com.facebook.stetho:stetho-okhttp3:1.4.1| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.android.support:support-v4:25.0.0 (*)+--- com.android.support:cardview-v7:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.jakewharton:butterknife:8.3.0| +--- com.jakewharton:butterknife-annotations:8.3.0| | \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0| \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0+--- org.jsoup:jsoup:1.9.2+--- com.google.code.gson:gson:2.7+--- com.squareup.okhttp3:okhttp:3.4.1| \--- com.squareup.okio:okio:1.9.0+--- com.squareup.picasso:picasso:2.5.2+--- io.reactivex:rxjava:1.1.6+--- com.tencent.bugly:crashreport:2.2.2+--- com.facebook.stetho:stetho:1.4.1| +--- commons-cli:commons-cli:1.2| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.facebook.stetho:stetho-js-rhino:1.4.1| +--- com.google.code.findbugs:jsr305:2.0.1| \--- org.mozilla:rhino:1.7.6+--- io.realm:realm-android-library:2.0.0| +--- io.realm:realm-annotations:2.0.0| \--- com.getkeepsafe.relinker:relinker:1.2.2+--- project :widget| +--- com.android.support:appcompat-v7:25.0.0 (*)| +--- com.android.support:design:25.0.0| | +--- com.android.support:support-v4:25.0.0 (*)| | +--- com.android.support:appcompat-v7:25.0.0 (*)| | +--- com.android.support:recyclerview-v7:25.0.0 (*)| | \--- com.android.support:transition:25.0.0| | \--- com.android.support:support-v4:25.0.0 (*)| \--- com.google.android:flexbox:0.2.3| \--- com.android.support:appcompat-v7:23.3.0 -&gt; 25.0.0 (*)\--- com.squareup.leakcanary:leakcanary-android:1.4 \--- com.squareup.leakcanary:leakcanary-analyzer:1.4 +--- com.squareup.haha:haha:2.0.3 \--- com.squareup.leakcanary:leakcanary-watcher:1.4_debugCompile - ## Internal use, do not manually configure ##+--- io.realm:realm-annotations:2.0.0+--- com.android.support:appcompat-v7:24.2.1 -&gt; 25.0.0| +--- com.android.support:support-v4:25.0.0| | +--- com.android.support:support-compat:25.0.0| | | \--- com.android.support:support-annotations:25.0.0| | +--- com.android.support:support-media-compat:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-core-utils:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-core-ui:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | \--- com.android.support:support-fragment:25.0.0| | +--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-media-compat:25.0.0 (*)| | +--- com.android.support:support-core-ui:25.0.0 (*)| | \--- com.android.support:support-core-utils:25.0.0 (*)| +--- com.android.support:support-vector-drawable:25.0.0| | \--- com.android.support:support-compat:25.0.0 (*)| \--- com.android.support:animated-vector-drawable:25.0.0| \--- com.android.support:support-vector-drawable:25.0.0 (*)+--- com.android.support:recyclerview-v7:25.0.0| +--- com.android.support:support-annotations:25.0.0| +--- com.android.support:support-compat:25.0.0 (*)| \--- com.android.support:support-core-ui:25.0.0 (*)+--- com.github.CymChad:BaseRecyclerViewAdapterHelper:2.2.9+--- com.youzan:titan:0.2.5| \--- com.android.support:recyclerview-v7:23.3.0 -&gt; 25.0.0 (*)+--- com.android.support:customtabs:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.squareup.okhttp3:logging-interceptor:3.4.1+--- com.squareup.retrofit2:retrofit:2.1.0+--- com.squareup.retrofit2:converter-gson:2.1.0| \--- com.google.code.gson:gson:2.7+--- com.squareup.retrofit2:adapter-rxjava:2.1.0| \--- io.reactivex:rxjava:1.1.5 -&gt; 1.1.6+--- jp.wasabeef:picasso-transformations:2.1.0+--- io.reactivex:rxandroid:1.2.1+--- xiaofei.library:hermes-eventbus:0.2.0| +--- xiaofei.library:concurrent-utils:0.1.4| +--- org.greenrobot:eventbus:3.0.0| \--- xiaofei.library:hermes:0.6.1+--- com.facebook.stetho:stetho-okhttp3:1.4.1| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.android.support:support-v4:25.0.0 (*)+--- com.android.support:cardview-v7:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.jakewharton:butterknife:8.3.0| +--- com.jakewharton:butterknife-annotations:8.3.0| | \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0| \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0+--- org.jsoup:jsoup:1.9.2+--- com.google.code.gson:gson:2.7+--- com.squareup.okhttp3:okhttp:3.4.1| \--- com.squareup.okio:okio:1.9.0+--- com.squareup.picasso:picasso:2.5.2+--- io.reactivex:rxjava:1.1.6+--- com.tencent.bugly:crashreport:2.2.2+--- com.facebook.stetho:stetho:1.4.1| +--- commons-cli:commons-cli:1.2| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.facebook.stetho:stetho-js-rhino:1.4.1| +--- com.google.code.findbugs:jsr305:2.0.1| \--- org.mozilla:rhino:1.7.6+--- io.realm:realm-android-library:2.0.0| +--- io.realm:realm-annotations:2.0.0| \--- com.getkeepsafe.relinker:relinker:1.2.2+--- project :widget| +--- com.android.support:appcompat-v7:25.0.0 (*)| +--- com.android.support:design:25.0.0| | +--- com.android.support:support-v4:25.0.0 (*)| | +--- com.android.support:appcompat-v7:25.0.0 (*)| | +--- com.android.support:recyclerview-v7:25.0.0 (*)| | \--- com.android.support:transition:25.0.0| | \--- com.android.support:support-v4:25.0.0 (*)| \--- com.google.android:flexbox:0.2.3| \--- com.android.support:appcompat-v7:23.3.0 -&gt; 25.0.0 (*)\--- com.squareup.leakcanary:leakcanary-android:1.4 \--- com.squareup.leakcanary:leakcanary-analyzer:1.4 +--- com.squareup.haha:haha:2.0.3 \--- com.squareup.leakcanary:leakcanary-watcher:1.4_debugUnitTestAnnotationProcessor - ## Internal use, do not manually configure ##No dependencies_debugUnitTestApk - ## Internal use, do not manually configure ##\--- junit:junit:4.12 \--- org.hamcrest:hamcrest-core:1.3_debugUnitTestCompile - ## Internal use, do not manually configure ##\--- junit:junit:4.12 \--- org.hamcrest:hamcrest-core:1.3_releaseAnnotationProcessor - ## Internal use, do not manually configure ##No dependencies_releaseApk - ## Internal use, do not manually configure ##+--- io.realm:realm-annotations:2.0.0+--- com.android.support:appcompat-v7:24.2.1 -&gt; 25.0.0| +--- com.android.support:support-v4:25.0.0| | +--- com.android.support:support-compat:25.0.0| | | \--- com.android.support:support-annotations:25.0.0| | +--- com.android.support:support-media-compat:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-core-utils:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-core-ui:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | \--- com.android.support:support-fragment:25.0.0| | +--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-media-compat:25.0.0 (*)| | +--- com.android.support:support-core-ui:25.0.0 (*)| | \--- com.android.support:support-core-utils:25.0.0 (*)| +--- com.android.support:support-vector-drawable:25.0.0| | \--- com.android.support:support-compat:25.0.0 (*)| \--- com.android.support:animated-vector-drawable:25.0.0| \--- com.android.support:support-vector-drawable:25.0.0 (*)+--- com.android.support:recyclerview-v7:25.0.0| +--- com.android.support:support-annotations:25.0.0| +--- com.android.support:support-compat:25.0.0 (*)| \--- com.android.support:support-core-ui:25.0.0 (*)+--- com.github.CymChad:BaseRecyclerViewAdapterHelper:2.2.9+--- com.youzan:titan:0.2.5| \--- com.android.support:recyclerview-v7:23.3.0 -&gt; 25.0.0 (*)+--- com.android.support:customtabs:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.squareup.okhttp3:logging-interceptor:3.4.1+--- com.squareup.retrofit2:retrofit:2.1.0+--- com.squareup.retrofit2:converter-gson:2.1.0| \--- com.google.code.gson:gson:2.7+--- com.squareup.retrofit2:adapter-rxjava:2.1.0| \--- io.reactivex:rxjava:1.1.5 -&gt; 1.1.6+--- jp.wasabeef:picasso-transformations:2.1.0+--- io.reactivex:rxandroid:1.2.1+--- xiaofei.library:hermes-eventbus:0.2.0| +--- xiaofei.library:concurrent-utils:0.1.4| +--- org.greenrobot:eventbus:3.0.0| \--- xiaofei.library:hermes:0.6.1+--- com.facebook.stetho:stetho-okhttp3:1.4.1| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.android.support:support-v4:25.0.0 (*)+--- com.android.support:cardview-v7:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.jakewharton:butterknife:8.3.0| +--- com.jakewharton:butterknife-annotations:8.3.0| | \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0| \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0+--- org.jsoup:jsoup:1.9.2+--- com.google.code.gson:gson:2.7+--- com.squareup.okhttp3:okhttp:3.4.1| \--- com.squareup.okio:okio:1.9.0+--- com.squareup.picasso:picasso:2.5.2+--- io.reactivex:rxjava:1.1.6+--- com.tencent.bugly:crashreport:2.2.2+--- com.facebook.stetho:stetho:1.4.1| +--- commons-cli:commons-cli:1.2| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.facebook.stetho:stetho-js-rhino:1.4.1| +--- com.google.code.findbugs:jsr305:2.0.1| \--- org.mozilla:rhino:1.7.6+--- io.realm:realm-android-library:2.0.0| +--- io.realm:realm-annotations:2.0.0| \--- com.getkeepsafe.relinker:relinker:1.2.2+--- project :widget| +--- com.android.support:appcompat-v7:25.0.0 (*)| +--- com.android.support:design:25.0.0| | +--- com.android.support:support-v4:25.0.0 (*)| | +--- com.android.support:appcompat-v7:25.0.0 (*)| | +--- com.android.support:recyclerview-v7:25.0.0 (*)| | \--- com.android.support:transition:25.0.0| | \--- com.android.support:support-v4:25.0.0 (*)| \--- com.google.android:flexbox:0.2.3| \--- com.android.support:appcompat-v7:23.3.0 -&gt; 25.0.0 (*)\--- com.squareup.leakcanary:leakcanary-android-no-op:1.4_releaseCompile - ## Internal use, do not manually configure ##+--- io.realm:realm-annotations:2.0.0+--- com.android.support:appcompat-v7:24.2.1 -&gt; 25.0.0| +--- com.android.support:support-v4:25.0.0| | +--- com.android.support:support-compat:25.0.0| | | \--- com.android.support:support-annotations:25.0.0| | +--- com.android.support:support-media-compat:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-core-utils:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-core-ui:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | \--- com.android.support:support-fragment:25.0.0| | +--- com.android.support:support-compat:25.0.0 (*)| | +--- com.android.support:support-media-compat:25.0.0 (*)| | +--- com.android.support:support-core-ui:25.0.0 (*)| | \--- com.android.support:support-core-utils:25.0.0 (*)| +--- com.android.support:support-vector-drawable:25.0.0| | \--- com.android.support:support-compat:25.0.0 (*)| \--- com.android.support:animated-vector-drawable:25.0.0| \--- com.android.support:support-vector-drawable:25.0.0 (*)+--- com.android.support:recyclerview-v7:25.0.0| +--- com.android.support:support-annotations:25.0.0| +--- com.android.support:support-compat:25.0.0 (*)| \--- com.android.support:support-core-ui:25.0.0 (*)+--- com.github.CymChad:BaseRecyclerViewAdapterHelper:2.2.9+--- com.youzan:titan:0.2.5| \--- com.android.support:recyclerview-v7:23.3.0 -&gt; 25.0.0 (*)+--- com.android.support:customtabs:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.squareup.okhttp3:logging-interceptor:3.4.1+--- com.squareup.retrofit2:retrofit:2.1.0+--- com.squareup.retrofit2:converter-gson:2.1.0| \--- com.google.code.gson:gson:2.7+--- com.squareup.retrofit2:adapter-rxjava:2.1.0| \--- io.reactivex:rxjava:1.1.5 -&gt; 1.1.6+--- jp.wasabeef:picasso-transformations:2.1.0+--- io.reactivex:rxandroid:1.2.1+--- xiaofei.library:hermes-eventbus:0.2.0| +--- xiaofei.library:concurrent-utils:0.1.4| +--- org.greenrobot:eventbus:3.0.0| \--- xiaofei.library:hermes:0.6.1+--- com.facebook.stetho:stetho-okhttp3:1.4.1| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.android.support:support-v4:25.0.0 (*)+--- com.android.support:cardview-v7:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.jakewharton:butterknife:8.3.0| +--- com.jakewharton:butterknife-annotations:8.3.0| | \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0| \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0+--- org.jsoup:jsoup:1.9.2+--- com.google.code.gson:gson:2.7+--- com.squareup.okhttp3:okhttp:3.4.1| \--- com.squareup.okio:okio:1.9.0+--- com.squareup.picasso:picasso:2.5.2+--- io.reactivex:rxjava:1.1.6+--- com.tencent.bugly:crashreport:2.2.2+--- com.facebook.stetho:stetho:1.4.1| +--- commons-cli:commons-cli:1.2| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.facebook.stetho:stetho-js-rhino:1.4.1| +--- com.google.code.findbugs:jsr305:2.0.1| \--- org.mozilla:rhino:1.7.6+--- io.realm:realm-android-library:2.0.0| +--- io.realm:realm-annotations:2.0.0| \--- com.getkeepsafe.relinker:relinker:1.2.2+--- project :widget| +--- com.android.support:appcompat-v7:25.0.0 (*)| +--- com.android.support:design:25.0.0| | +--- com.android.support:support-v4:25.0.0 (*)| | +--- com.android.support:appcompat-v7:25.0.0 (*)| | +--- com.android.support:recyclerview-v7:25.0.0 (*)| | \--- com.android.support:transition:25.0.0| | \--- com.android.support:support-v4:25.0.0 (*)| \--- com.google.android:flexbox:0.2.3| \--- com.android.support:appcompat-v7:23.3.0 -&gt; 25.0.0 (*)\--- com.squareup.leakcanary:leakcanary-android-no-op:1.4_releaseUnitTestAnnotationProcessor - ## Internal use, do not manually configure ##No dependencies_releaseUnitTestApk - ## Internal use, do not manually configure ##\--- junit:junit:4.12 \--- org.hamcrest:hamcrest-core:1.3_releaseUnitTestCompile - ## Internal use, do not manually configure ##\--- junit:junit:4.12 \--- org.hamcrest:hamcrest-core:1.3androidJacocoAgent - The Jacoco agent to use to get coverage data.\--- org.jacoco:org.jacoco.agent:0.7.5.201505241946androidJacocoAnt - The Jacoco ant tasks to use to get execute Gradle tasks.\--- org.jacoco:org.jacoco.ant:0.7.5.201505241946 +--- org.jacoco:org.jacoco.core:0.7.5.201505241946 | \--- org.ow2.asm:asm-debug-all:5.0.1 +--- org.jacoco:org.jacoco.report:0.7.5.201505241946 | +--- org.jacoco:org.jacoco.core:0.7.5.201505241946 (*) | \--- org.ow2.asm:asm-debug-all:5.0.1 \--- org.jacoco:org.jacoco.agent:0.7.5.201505241946androidTestAnnotationProcessor - Classpath for the annotation processor for &apos;androidTest&apos;.No dependenciesandroidTestApk - Classpath packaged with the compiled &apos;androidTest&apos; classes.No dependenciesandroidTestApt+--- io.realm:realm-annotations:2.0.0\--- io.realm:realm-annotations-processor:2.0.0 +--- com.squareup:javawriter:2.5.0 \--- io.realm:realm-annotations:2.0.0androidTestCompile - Classpath for compiling the androidTest sources.No dependenciesandroidTestProvided - Classpath for only compiling the androidTest sources.No dependenciesandroidTestWearApp - Link to a wear app to embed for object &apos;androidTest&apos;.No dependenciesannotationProcessor - Classpath for the annotation processor for &apos;main&apos;.No dependenciesapk - Classpath packaged with the compiled &apos;main&apos; classes.No dependenciesapt+--- io.realm:realm-annotations:2.0.0+--- io.realm:realm-annotations-processor:2.0.0| +--- com.squareup:javawriter:2.5.0| \--- io.realm:realm-annotations:2.0.0+--- com.jakewharton:butterknife-compiler:8.3.0| +--- com.jakewharton:butterknife-annotations:8.3.0| | \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0| +--- com.google.auto:auto-common:0.6| | \--- com.google.guava:guava:18.0| +--- com.google.auto.service:auto-service:1.0-rc2| | +--- com.google.auto:auto-common:0.3 -&gt; 0.6 (*)| | \--- com.google.guava:guava:18.0| \--- com.squareup:javapoet:1.7.0+--- com.android.support:appcompat-v7:24.2.1| \--- com.android.support:animated-vector-drawable:24.2.1+--- com.android.support:recyclerview-v7:25.0.0| +--- com.android.support:support-annotations:25.0.0| +--- com.android.support:support-compat:25.0.0| | \--- com.android.support:support-annotations:25.0.0| \--- com.android.support:support-core-ui:25.0.0| \--- com.android.support:support-compat:25.0.0 (*)+--- com.github.CymChad:BaseRecyclerViewAdapterHelper:2.2.9+--- com.youzan:titan:0.2.5| \--- com.android.support:recyclerview-v7:23.3.0 -&gt; 25.0.0 (*)+--- com.android.support:customtabs:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.squareup.okhttp3:logging-interceptor:3.4.1+--- com.squareup.retrofit2:retrofit:2.1.0+--- com.squareup.retrofit2:converter-gson:2.1.0| \--- com.google.code.gson:gson:2.7+--- com.squareup.retrofit2:adapter-rxjava:2.1.0| \--- io.reactivex:rxjava:1.1.5 -&gt; 1.1.6+--- jp.wasabeef:picasso-transformations:2.1.0+--- io.reactivex:rxandroid:1.2.1+--- xiaofei.library:hermes-eventbus:0.2.0| +--- xiaofei.library:concurrent-utils:0.1.4| +--- org.greenrobot:eventbus:3.0.0| \--- xiaofei.library:hermes:0.6.1+--- com.facebook.stetho:stetho-okhttp3:1.4.1| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.android.support:support-v4:25.0.0| +--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-media-compat:25.0.0| | \--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-core-utils:25.0.0| | \--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-core-ui:25.0.0 (*)| \--- com.android.support:support-fragment:25.0.0| +--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-media-compat:25.0.0 (*)| +--- com.android.support:support-core-ui:25.0.0 (*)| \--- com.android.support:support-core-utils:25.0.0 (*)+--- com.android.support:cardview-v7:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.jakewharton:butterknife:8.3.0| +--- com.jakewharton:butterknife-annotations:8.3.0 (*)| \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0+--- org.jsoup:jsoup:1.9.2+--- com.google.code.gson:gson:2.7+--- com.squareup.okhttp3:okhttp:3.4.1| \--- com.squareup.okio:okio:1.9.0+--- com.squareup.picasso:picasso:2.5.2+--- io.reactivex:rxjava:1.1.6+--- com.tencent.bugly:crashreport:2.2.2+--- com.facebook.stetho:stetho:1.4.1| +--- commons-cli:commons-cli:1.2| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.facebook.stetho:stetho-js-rhino:1.4.1| +--- com.google.code.findbugs:jsr305:2.0.1| \--- org.mozilla:rhino:1.7.6\--- io.realm:realm-android-library:2.0.0 +--- io.realm:realm-annotations:2.0.0 \--- com.getkeepsafe.relinker:relinker:1.2.2archives - Configuration for archive artifacts.No dependenciescompile - Classpath for compiling the main sources.+--- io.realm:realm-annotations:2.0.0+--- com.android.support:appcompat-v7:24.2.1| \--- com.android.support:animated-vector-drawable:24.2.1+--- com.android.support:recyclerview-v7:25.0.0| +--- com.android.support:support-annotations:25.0.0| +--- com.android.support:support-compat:25.0.0| | \--- com.android.support:support-annotations:25.0.0| \--- com.android.support:support-core-ui:25.0.0| \--- com.android.support:support-compat:25.0.0 (*)+--- com.github.CymChad:BaseRecyclerViewAdapterHelper:2.2.9+--- com.youzan:titan:0.2.5| \--- com.android.support:recyclerview-v7:23.3.0 -&gt; 25.0.0 (*)+--- com.android.support:customtabs:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.squareup.okhttp3:logging-interceptor:3.4.1+--- com.squareup.retrofit2:retrofit:2.1.0+--- com.squareup.retrofit2:converter-gson:2.1.0| \--- com.google.code.gson:gson:2.7+--- com.squareup.retrofit2:adapter-rxjava:2.1.0| \--- io.reactivex:rxjava:1.1.5 -&gt; 1.1.6+--- jp.wasabeef:picasso-transformations:2.1.0+--- io.reactivex:rxandroid:1.2.1+--- xiaofei.library:hermes-eventbus:0.2.0| +--- xiaofei.library:concurrent-utils:0.1.4| +--- org.greenrobot:eventbus:3.0.0| \--- xiaofei.library:hermes:0.6.1+--- com.facebook.stetho:stetho-okhttp3:1.4.1| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.android.support:support-v4:25.0.0| +--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-media-compat:25.0.0| | \--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-core-utils:25.0.0| | \--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-core-ui:25.0.0 (*)| \--- com.android.support:support-fragment:25.0.0| +--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-media-compat:25.0.0 (*)| +--- com.android.support:support-core-ui:25.0.0 (*)| \--- com.android.support:support-core-utils:25.0.0 (*)+--- com.android.support:cardview-v7:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.jakewharton:butterknife:8.3.0| +--- com.jakewharton:butterknife-annotations:8.3.0| | \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0| \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0+--- org.jsoup:jsoup:1.9.2+--- com.google.code.gson:gson:2.7+--- com.squareup.okhttp3:okhttp:3.4.1| \--- com.squareup.okio:okio:1.9.0+--- com.squareup.picasso:picasso:2.5.2+--- io.reactivex:rxjava:1.1.6+--- com.tencent.bugly:crashreport:2.2.2+--- com.facebook.stetho:stetho:1.4.1| +--- commons-cli:commons-cli:1.2| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.facebook.stetho:stetho-js-rhino:1.4.1| +--- com.google.code.findbugs:jsr305:2.0.1| \--- org.mozilla:rhino:1.7.6\--- io.realm:realm-android-library:2.0.0 +--- io.realm:realm-annotations:2.0.0 \--- com.getkeepsafe.relinker:relinker:1.2.2debugAnnotationProcessor - Classpath for the annotation processor for &apos;debug&apos;.No dependenciesdebugApk - Classpath packaged with the compiled &apos;debug&apos; classes.No dependenciesdebugCompile - Classpath for compiling the debug sources.+--- project :widget| +--- com.android.support:appcompat-v7:25.0.0| | +--- com.android.support:support-v4:25.0.0| | | +--- com.android.support:support-compat:25.0.0| | | | \--- com.android.support:support-annotations:25.0.0| | | +--- com.android.support:support-media-compat:25.0.0| | | | \--- com.android.support:support-compat:25.0.0 (*)| | | +--- com.android.support:support-core-utils:25.0.0| | | | \--- com.android.support:support-compat:25.0.0 (*)| | | +--- com.android.support:support-core-ui:25.0.0| | | | \--- com.android.support:support-compat:25.0.0 (*)| | | \--- com.android.support:support-fragment:25.0.0| | | +--- com.android.support:support-compat:25.0.0 (*)| | | +--- com.android.support:support-media-compat:25.0.0 (*)| | | +--- com.android.support:support-core-ui:25.0.0 (*)| | | \--- com.android.support:support-core-utils:25.0.0 (*)| | +--- com.android.support:support-vector-drawable:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | \--- com.android.support:animated-vector-drawable:25.0.0| | \--- com.android.support:support-vector-drawable:25.0.0 (*)| +--- com.android.support:design:25.0.0| | +--- com.android.support:support-v4:25.0.0 (*)| | +--- com.android.support:appcompat-v7:25.0.0 (*)| | +--- com.android.support:recyclerview-v7:25.0.0| | | +--- com.android.support:support-annotations:25.0.0| | | +--- com.android.support:support-compat:25.0.0 (*)| | | \--- com.android.support:support-core-ui:25.0.0 (*)| | \--- com.android.support:transition:25.0.0| | \--- com.android.support:support-v4:25.0.0 (*)| \--- com.google.android:flexbox:0.2.3| \--- com.android.support:appcompat-v7:23.3.0 -&gt; 25.0.0 (*)\--- com.squareup.leakcanary:leakcanary-android:1.4 \--- com.squareup.leakcanary:leakcanary-analyzer:1.4 +--- com.squareup.haha:haha:2.0.3 \--- com.squareup.leakcanary:leakcanary-watcher:1.4debugProvided - Classpath for only compiling the debug sources.No dependenciesdebugWearApp - Link to a wear app to embed for object &apos;debug&apos;.No dependenciesdefault - Configuration for default artifacts.No dependenciesdefault-mapping - Configuration for default mapping artifacts.No dependenciesdefault-metadata - Metadata for the produced APKs.No dependenciesprovided - Classpath for only compiling the main sources.No dependenciesreleaseAnnotationProcessor - Classpath for the annotation processor for &apos;release&apos;.No dependenciesreleaseApk - Classpath packaged with the compiled &apos;release&apos; classes.No dependenciesreleaseCompile - Classpath for compiling the release sources.+--- project :widget| +--- com.android.support:appcompat-v7:25.0.0| | +--- com.android.support:support-v4:25.0.0| | | +--- com.android.support:support-compat:25.0.0| | | | \--- com.android.support:support-annotations:25.0.0| | | +--- com.android.support:support-media-compat:25.0.0| | | | \--- com.android.support:support-compat:25.0.0 (*)| | | +--- com.android.support:support-core-utils:25.0.0| | | | \--- com.android.support:support-compat:25.0.0 (*)| | | +--- com.android.support:support-core-ui:25.0.0| | | | \--- com.android.support:support-compat:25.0.0 (*)| | | \--- com.android.support:support-fragment:25.0.0| | | +--- com.android.support:support-compat:25.0.0 (*)| | | +--- com.android.support:support-media-compat:25.0.0 (*)| | | +--- com.android.support:support-core-ui:25.0.0 (*)| | | \--- com.android.support:support-core-utils:25.0.0 (*)| | +--- com.android.support:support-vector-drawable:25.0.0| | | \--- com.android.support:support-compat:25.0.0 (*)| | \--- com.android.support:animated-vector-drawable:25.0.0| | \--- com.android.support:support-vector-drawable:25.0.0 (*)| +--- com.android.support:design:25.0.0| | +--- com.android.support:support-v4:25.0.0 (*)| | +--- com.android.support:appcompat-v7:25.0.0 (*)| | +--- com.android.support:recyclerview-v7:25.0.0| | | +--- com.android.support:support-annotations:25.0.0| | | +--- com.android.support:support-compat:25.0.0 (*)| | | \--- com.android.support:support-core-ui:25.0.0 (*)| | \--- com.android.support:transition:25.0.0| | \--- com.android.support:support-v4:25.0.0 (*)| \--- com.google.android:flexbox:0.2.3| \--- com.android.support:appcompat-v7:23.3.0 -&gt; 25.0.0 (*)\--- com.squareup.leakcanary:leakcanary-android-no-op:1.4releaseProvided - Classpath for only compiling the release sources.No dependenciesreleaseWearApp - Link to a wear app to embed for object &apos;release&apos;.No dependenciesretrolambdaConfig\--- net.orfjackal.retrolambda:retrolambda:2.1.0testAnnotationProcessor - Classpath for the annotation processor for &apos;test&apos;.No dependenciestestApk - Classpath packaged with the compiled &apos;test&apos; classes.No dependenciestestApt\--- junit:junit:4.12 \--- org.hamcrest:hamcrest-core:1.3testCompile - Classpath for compiling the test sources.\--- junit:junit:4.12 \--- org.hamcrest:hamcrest-core:1.3testDebugAnnotationProcessor - Classpath for the annotation processor for &apos;testDebug&apos;.No dependenciestestDebugApk - Classpath packaged with the compiled &apos;testDebug&apos; classes.No dependenciestestDebugCompile - Classpath for compiling the testDebug sources.No dependenciestestDebugProvided - Classpath for only compiling the testDebug sources.No dependenciestestDebugWearApp - Link to a wear app to embed for object &apos;testDebug&apos;.No dependenciestestProvided - Classpath for only compiling the test sources.No dependenciestestReleaseAnnotationProcessor - Classpath for the annotation processor for &apos;testRelease&apos;.No dependenciestestReleaseApk - Classpath packaged with the compiled &apos;testRelease&apos; classes.No dependenciestestReleaseCompile - Classpath for compiling the testRelease sources.No dependenciestestReleaseProvided - Classpath for only compiling the testRelease sources.No dependenciestestReleaseWearApp - Link to a wear app to embed for object &apos;testRelease&apos;.No dependenciestestWearApp - Link to a wear app to embed for object &apos;test&apos;.No dependencieswearApp - Link to a wear app to embed for object &apos;main&apos;.No dependencies 查看指定依赖树gradle -q app:dependencies --configuration debug 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071panda:Gank panda$ gradle -q app:dependencies --configuration compile------------------------------------------------------------Project :app------------------------------------------------------------compile - Classpath for compiling the main sources.+--- io.realm:realm-annotations:2.0.0+--- com.android.support:appcompat-v7:24.2.1| \--- com.android.support:animated-vector-drawable:24.2.1+--- com.android.support:recyclerview-v7:25.0.0| +--- com.android.support:support-annotations:25.0.0| +--- com.android.support:support-compat:25.0.0| | \--- com.android.support:support-annotations:25.0.0| \--- com.android.support:support-core-ui:25.0.0| \--- com.android.support:support-compat:25.0.0 (*)+--- com.github.CymChad:BaseRecyclerViewAdapterHelper:2.2.9+--- com.youzan:titan:0.2.5| \--- com.android.support:recyclerview-v7:23.3.0 -&gt; 25.0.0 (*)+--- com.android.support:customtabs:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.squareup.okhttp3:logging-interceptor:3.4.1+--- com.squareup.retrofit2:retrofit:2.1.0+--- com.squareup.retrofit2:converter-gson:2.1.0| \--- com.google.code.gson:gson:2.7+--- com.squareup.retrofit2:adapter-rxjava:2.1.0| \--- io.reactivex:rxjava:1.1.5 -&gt; 1.1.6+--- jp.wasabeef:picasso-transformations:2.1.0+--- io.reactivex:rxandroid:1.2.1+--- xiaofei.library:hermes-eventbus:0.2.0| +--- xiaofei.library:concurrent-utils:0.1.4| +--- org.greenrobot:eventbus:3.0.0| \--- xiaofei.library:hermes:0.6.1+--- com.facebook.stetho:stetho-okhttp3:1.4.1| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.android.support:support-v4:25.0.0| +--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-media-compat:25.0.0| | \--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-core-utils:25.0.0| | \--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-core-ui:25.0.0 (*)| \--- com.android.support:support-fragment:25.0.0| +--- com.android.support:support-compat:25.0.0 (*)| +--- com.android.support:support-media-compat:25.0.0 (*)| +--- com.android.support:support-core-ui:25.0.0 (*)| \--- com.android.support:support-core-utils:25.0.0 (*)+--- com.android.support:cardview-v7:25.0.0| \--- com.android.support:support-annotations:25.0.0+--- com.jakewharton:butterknife:8.3.0| +--- com.jakewharton:butterknife-annotations:8.3.0| | \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0| \--- com.android.support:support-annotations:24.1.0 -&gt; 25.0.0+--- org.jsoup:jsoup:1.9.2+--- com.google.code.gson:gson:2.7+--- com.squareup.okhttp3:okhttp:3.4.1| \--- com.squareup.okio:okio:1.9.0+--- com.squareup.picasso:picasso:2.5.2+--- io.reactivex:rxjava:1.1.6+--- com.tencent.bugly:crashreport:2.2.2+--- com.facebook.stetho:stetho:1.4.1| +--- commons-cli:commons-cli:1.2| \--- com.google.code.findbugs:jsr305:2.0.1+--- com.facebook.stetho:stetho-js-rhino:1.4.1| +--- com.google.code.findbugs:jsr305:2.0.1| \--- org.mozilla:rhino:1.7.6\--- io.realm:realm-android-library:2.0.0 +--- io.realm:realm-annotations:2.0.0 \--- com.getkeepsafe.relinker:relinker:1.2.2(*) - dependencies omitted (listed previously) 构建先了解几个概念: Build Type: 构建类型。一般是 debug 和 release，也可以在 module 的 build.gradle 中自定义： 123456789101112131415161718192021222324android &#123; ...... ...... buildTypes &#123; debug &#123; buildConfigField "String", "API_HOST", '"http://gank.io/api/"' debuggable true minifyEnabled false shrinkResources false zipAlignEnabled false signingConfig signingConfigs.debug &#125; release &#123; buildConfigField "String", "API_HOST", '"http://gank.io/api/"' minifyEnabled true shrinkResources true zipAlignEnabled true signingConfig signingConfigs.release proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; ...... ......&#125; Product Flavor: 渠道名 比如下面我们配置的yingyongbao、wandoujia、beta 1234567891011121314productFlavors &#123; yingyongbao &#123; applicationId "com.sgb.gank" manifestPlaceholders = [APP_NAME: "Gank", CHANNEL_VALUE: 'yingyongbao', CHANNEL_ID: 1] &#125; wandoujia &#123; applicationId "com.sgb.gank" manifestPlaceholders = [APP_NAME: "Gank", CHANNEL_VALUE: 'wandoujia', CHANNEL_ID: 2] &#125; beta &#123; applicationId "com.sgb.gank.beta" manifestPlaceholders = [APP_NAME: "Gank.beta"] &#125;&#125; Build Variant: Product Flavor和Build Type的排列组合` assemble+BuildType./gradlew assembleRelease 构建所有渠道的 release 版本 assemble+ProductFlavor./gradlew assembleYingyongbao 构建指定渠道的所有 Build Type 版本 asselmbe+BuildVariant./gradlew assembleYingyongbaoRelease 构建指定渠道的指定版本 未完待续。。。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[library中BuildConfig.DEBUG始终为false的解决方法]]></title>
      <url>%2F2016%2F09%2F02%2Flibrary%E4%B8%ADBuildConfig-DEBUG%E5%A7%8B%E7%BB%88%E4%B8%BAfalse%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[参考： http://stackoverflow.com/questions/20176284/buildconfig-debug-always-false-when-building-library-projects-with-gradle# 修改默认的发布配置通过 android.publishNonDefault = true 启用其他variants的发布 通过 compile project(path: ‘:project’, configuration: ‘flavor1Debug’) 引用指定的variant library module : 123android &#123; publishNonDefault true&#125; app module: 1234dependencies &#123; debugCompile project(path: ':library', configuration: 'debug') releaseCompile project(path: ':library', configuration: 'release')&#125; 自定义buildconfig field library module: 12345678910android &#123; buildTypes &#123; debug &#123; buildConfigField "boolean", "LOG_DEBUG", "true" &#125; release &#123; buildConfigField "boolean", "LOG_DEBUG", "false" &#125; &#125;&#125; java code 123if (BuildConfig.LOG_DEBUG) &#123; // TODO&#125; ReBuild之后你会发现debug和release模式下BuildConfig中LOG_DEBUG的值是不同的。 这种方式不仅用与此，你还可以添加其他的字段，比如debug和release模式下不同的API base url，等等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo搭建以及多ssh key问题解决]]></title>
      <url>%2F2016%2F05%2F14%2FHexo%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%8F%8A%E5%A4%9Assh-key%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F05%2F14%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 常见问题如果修改配置文件提交不上去，就删除根目录下的.deploy_git文件，重新hexo g -d]]></content>
    </entry>

    
  
  
</search>
